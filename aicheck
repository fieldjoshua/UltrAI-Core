#!/bin/bash

# MCP: AICheck_Scoper  
# Action: AICheck-Core-Development
# DateTime: 2025-06-25 16:40:00 PDT
# Task: Maintain and develop AICheck core governance system
# File: aicheck
# You may only modify this file. Stay within the current action scope.
# Follow the approved plan and avoid scope creep.

# AICheck command script
# Provides the core functionality for AICheck MCP
# Version: 7.0.0
# Last Updated: 2025-06-25

set -e

# AICheck version info
AICHECK_VERSION="7.2.0"
GITHUB_REPO="fieldjoshua/AICheck_MCP"
GITHUB_RAW_BASE="https://raw.githubusercontent.com/${GITHUB_REPO}/main"

CMD=$1
shift || true
ARGS=$@

# Function to show version information
function show_version() {
  echo -e "${BRIGHT_BLURPLE}AICheck MCP${NC}"
  echo -e "Version: ${GREEN}${AICHECK_VERSION}${NC}"
  echo -e "Repository: ${GITHUB_REPO}"
  echo -e ""
  echo -e "${BRIGHT_BLURPLE}ðŸ“‹ Your Commands:${NC}"
  echo -e "  ${GREEN}./aicheck status${NC}         - Show detailed status"
  echo -e "  ${GREEN}./aicheck focus${NC}          - Check for scope creep"
  echo -e "  ${GREEN}./aicheck stuck${NC}          - Get unstuck when confused"
  echo -e "  ${GREEN}./aicheck deploy${NC}         - Pre-deployment validation"
  echo -e "  ${GREEN}./aicheck auto-iterate${NC}   - Automated test-fix-test cycles"
  echo -e "  ${GREEN}./aicheck new${NC}            - Create a new action"
  echo -e "  ${GREEN}./aicheck ACTIVE${NC}         - Set the ACTIVE action"
  echo -e "  ${GREEN}./aicheck complete${NC}       - Complete the ACTIVE action"
  echo -e "  ${GREEN}./aicheck cleanup${NC}        - Optimize and fix compliance"
  echo -e "  ${GREEN}./aicheck usage${NC}          - See AI usage and costs"
  echo -e ""
  echo -e "${BRIGHT_BLURPLE}ðŸ¤– AI Editor Integration:${NC}"
  echo -e "  ${GREEN}./aicheck mcp edit${NC}       - Setup MCP headers for AI coding"
  echo -e "  ${GREEN}./aicheck edit claude <file>${NC} - Launch Claude with MCP"
  echo -e "  ${GREEN}./aicheck edit cursor <file>${NC} - Launch Cursor with MCP"
  echo -e ""
  echo -e "${YELLOW}ðŸ’¡ Only one action can be ACTIVE at a time.${NC}"
}

# Function to check for updates
function check_for_updates() {
  echo -e "${BRIGHT_BLURPLE}Checking for updates...${NC}"
  
  # Get remote version
  local remote_version=$(curl -s "${GITHUB_RAW_BASE}/aicheck" | grep "AICHECK_VERSION=" | head -1 | cut -d'"' -f2)
  
  if [ -z "$remote_version" ]; then
    echo -e "${YELLOW}âš  Could not check remote version${NC}"
    return 1
  fi
  
  echo -e "Local version:  ${GREEN}${AICHECK_VERSION}${NC}"
  echo -e "Remote version: ${GREEN}${remote_version}${NC}"
  
  if [ "$AICHECK_VERSION" != "$remote_version" ]; then
    echo -e "${YELLOW}ðŸ”„ Update available: ${remote_version}${NC}"
    return 0
  else
    echo -e "${GREEN}âœ“ AICheck is up to date${NC}"
    return 1
  fi
}

# Function to backup current aicheck command
function backup_aicheck() {
  local script_path="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
  local backup_path="${script_path}.backup.$(date +%Y%m%d_%H%M%S)"
  
  if cp "$script_path" "$backup_path" 2>/dev/null; then
    echo -e "${GREEN}âœ“ Backup created: $(basename "$backup_path")${NC}"
    echo "$backup_path"
  else
    echo -e "${YELLOW}âš  Could not create backup${NC}"
    return 1
  fi
}

# Function to update aicheck command itself
function update_aicheck_command() {
  echo -e "${BRIGHT_BLURPLE}Updating AICheck command...${NC}"
  
  # Get the script path
  local script_path="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
  
  # Create backup
  local backup_path=$(backup_aicheck)
  if [ $? -ne 0 ]; then
    echo -e "${RED}âœ— Failed to create backup - aborting update${NC}"
    return 1
  fi
  
  # Download new version to temporary file
  local temp_file=$(mktemp)
  if curl -sL "${GITHUB_RAW_BASE}/aicheck" -o "$temp_file"; then
    # Verify the download is valid
    if bash -n "$temp_file" 2>/dev/null; then
      # Make sure it's executable and replace current script
      chmod +x "$temp_file"
      if mv "$temp_file" "$script_path"; then
        echo -e "${GREEN}âœ“ AICheck command updated successfully${NC}"
        echo -e "${BRIGHT_BLURPLE}Restart your session or run the command again to use the new version${NC}"
        return 0
      else
        echo -e "${RED}âœ— Failed to replace aicheck command${NC}"
        # Restore from backup
        mv "$backup_path" "$script_path"
        echo -e "${YELLOW}âš  Restored from backup${NC}"
        rm -f "$temp_file"
        return 1
      fi
    else
      echo -e "${RED}âœ— Downloaded file is not valid - aborting update${NC}"
      rm -f "$temp_file"
      return 1
    fi
  else
    echo -e "${RED}âœ— Failed to download aicheck command${NC}"
    rm -f "$temp_file"
    return 1
  fi
}

# Function to update AICheck rules
function update_rules() {
  echo -e "${BRIGHT_BLURPLE}Updating AICheck RULES.md...${NC}"
  
  # Make RULES.md writable if it exists
  if [ -f ".aicheck/RULES.md" ]; then
    chmod +w .aicheck/RULES.md
  fi
  
  # Download latest RULES.md
  if curl -sL "${GITHUB_RAW_BASE}/RULES.md" -o .aicheck/RULES.md; then
    echo -e "${GREEN}âœ“ RULES.md updated successfully${NC}"
    chmod 444 .aicheck/RULES.md  # Make read-only again
  else
    echo -e "${RED}âœ— Failed to update RULES.md - check internet connection${NC}"
    return 1
  fi
}

# Function to update everything (rules + command)
function update_all() {
  echo -e "${BRIGHT_BLURPLE}Updating AICheck system...${NC}"
  echo ""
  
  # Check if updates are available
  if ! check_for_updates; then
    echo -e "${GREEN}âœ“ No updates needed${NC}"
    return 0
  fi
  
  echo ""
  local rules_updated=false
  local command_updated=false
  
  # Update RULES.md
  if update_rules; then
    rules_updated=true
  fi
  
  echo ""
  
  # Update aicheck command
  if update_aicheck_command; then
    command_updated=true
  fi
  
  echo ""
  echo -e "${BRIGHT_BLURPLE}Update Summary:${NC}"
  echo -e "RULES.md: $([ "$rules_updated" = true ] && echo -e "${GREEN}âœ“ Updated${NC}" || echo -e "${RED}âœ— Failed${NC}")"
  echo -e "AICheck command: $([ "$command_updated" = true ] && echo -e "${GREEN}âœ“ Updated${NC}" || echo -e "${RED}âœ— Failed${NC}")"
  
  if [ "$rules_updated" = true ] || [ "$command_updated" = true ]; then
    echo -e "${GREEN}âœ“ AICheck system updated successfully${NC}"
    if [ "$command_updated" = true ]; then
      echo -e "${YELLOW}âš  Please restart your session or run the command again${NC}"
    fi
  else
    echo -e "${RED}âœ— Update failed${NC}"
    return 1
  fi
}

GREEN="\033[0;32m"
NEON_BLURPLE="\033[38;5;99m"      # Neon blurple highlight color
BRIGHT_BLURPLE="\033[38;5;135m"   # Bright blurple for text
YELLOW="\033[0;33m"
RED="\033[0;31m"
CYAN="\033[0;36m"
NC="\033[0m" # No Color
BLUE="\033[0;34m"
PURPLE="\033[0;35m"

# Function to validate single active action principle
function validate_single_active_action() {
  # Only run for commands that need validation
  local cmd=${1:-}
  case "$cmd" in
    "status"|"focus"|"deploy"|"complete"|"auto-iterate"|"ACTIVE"|"new")
      # These commands need validation
      ;;
    *)
      # Skip validation for other commands
      return 0
      ;;
  esac
  
  # Count active actions
  local index_active=$(grep -c "| .* | .* | ActiveAction | .* | .* |" .aicheck/actions_index.md 2>/dev/null | tr -d '\n')
  index_active=${index_active:-0}
  local current=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$index_active" -gt 1 ]; then
    echo -e "${RED}âš  ERROR: Multiple active actions detected!${NC}"
    echo -e "${YELLOW}AICheck requires exactly ONE active action at a time.${NC}"
    echo -e "${CYAN}Run './aicheck cleanup' to fix this issue.${NC}"
    echo ""
    return 1
  elif [ "$index_active" -eq 0 ] && [ "$current" != "None" ] && [ "$current" != "" ]; then
    echo -e "${YELLOW}âš  WARNING: Inconsistent state detected${NC}"
    echo -e "${CYAN}Current action is '$current' but not marked active in index.${NC}"
    echo -e "${CYAN}Run './aicheck cleanup' to fix this issue.${NC}"
    echo ""
    return 1
  fi
  return 0
}

# Function to automatically detect context pollution
function detect_context_pollution() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  local pollution_score=0
  local warnings=()
  
  # Check for multiple active actions
  if [ -d ".aicheck/actions" ]; then
    local active_count=$(find .aicheck/actions -name "status.txt" -exec grep -l "ActiveAction" {} \; 2>/dev/null | wc -l | tr -d ' ')
    if [ "$active_count" -gt 1 ]; then
      pollution_score=$((pollution_score + 30))
      warnings+=("Multiple active actions detected ($active_count)")
    fi
  fi
  
  # Check for excessive Claude interaction logs in the last hour
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    local interaction_dir=".aicheck/actions/$dir_name/supporting_docs/claude-interactions"
    if [ -d "$interaction_dir" ]; then
      local recent_interactions=$(find "$interaction_dir" -name "*.md" -mmin -60 2>/dev/null | wc -l | tr -d ' ')
      if [ "$recent_interactions" -gt 10 ]; then
        pollution_score=$((pollution_score + 20))
        warnings+=("High interaction frequency: $recent_interactions in last hour")
      fi
    fi
  fi
  
  # Check for uncommitted changes across multiple directories
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local changed_dirs=$(git status --porcelain 2>/dev/null | awk '{print $2}' | xargs dirname | sort -u | wc -l | tr -d ' ')
    if [ "$changed_dirs" -gt 3 ]; then
      pollution_score=$((pollution_score + 15))
      warnings+=("Changes scattered across $changed_dirs directories")
    fi
  fi
  
  echo "$pollution_score"
  if [ ${#warnings[@]} -gt 0 ]; then
    echo "WARNINGS:"
    printf '%s\n' "${warnings[@]}"
  fi
}

# Function to automatically clear context (with approval for destructive actions)
function clear_context() {
  local force=$1
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Context Clear${NC}"
  echo -e "Analyzing current context state..."
  
  local pollution_data=$(detect_context_pollution)
  local pollution_score=$(echo "$pollution_data" | head -1 | grep -o '[0-9]*' || echo "0")
  local warnings=$(echo "$pollution_data" | tail -n +2)
  
  # Ensure pollution_score is a valid number
  if ! [[ "$pollution_score" =~ ^[0-9]+$ ]]; then
    pollution_score=0
  fi
  
  echo -e "Context pollution score: ${GREEN}$pollution_score/100${NC}"
  if [ -n "$warnings" ]; then
    echo -e "${YELLOW}$warnings${NC}"
  fi
  
  # Automated safe actions (no approval needed)
  echo -e "\n${BRIGHT_BLURPLE}Performing automated context cleanup...${NC}"
  
  # Clean up temp files
  find . -name "*.tmp" -o -name "*.temp" -o -name ".DS_Store" 2>/dev/null | xargs rm -f 2>/dev/null || true
  echo -e "${GREEN}âœ“ Cleaned temporary files${NC}"
  
  # Reset any exec mode state safely
  if [ "$current_action" = "AICheckExec" ] && [ -f ".aicheck/previous_action" ]; then
    local previous=$(cat .aicheck/previous_action)
    echo "$previous" > .aicheck/current_action
    rm .aicheck/previous_action
    echo -e "${GREEN}âœ“ Restored from exec mode to: $previous${NC}"
  fi
  
  # Archive old interaction logs (keep last 5 per action)
  if [ -d ".aicheck/actions" ]; then
    find .aicheck/actions -name "claude-interactions" -type d | while read dir; do
      if [ $(ls "$dir"/*.md 2>/dev/null | wc -l) -gt 5 ]; then
        mkdir -p "$dir/archive"
        ls -t "$dir"/*.md 2>/dev/null | tail -n +6 | xargs mv -t "$dir/archive/" 2>/dev/null || true
      fi
    done
    echo -e "${GREEN}âœ“ Archived old interaction logs${NC}"
  fi
  
  # Actions requiring approval
  local needs_approval=false
  local approval_actions=()
  
  if [ "${pollution_score:-0}" -gt 50 ]; then
    needs_approval=true
    approval_actions+=("Reset all active actions to 'Not Started'")
    approval_actions+=("Clear all uncommitted git changes")
    approval_actions+=("Reset current action to 'None'")
  fi
  
  if [ "$force" != "--force" ] && [ "$needs_approval" = true ]; then
    echo -e "\n${YELLOW}The following actions require human approval:${NC}"
    printf '  - %s\n' "${approval_actions[@]}"
    echo -e "\n${YELLOW}Run './aicheck context clear --force' to proceed with destructive actions${NC}"
    echo -e "${YELLOW}Or manually address the issues listed above${NC}"
    return 0
  fi
  
  if [ "$force" = "--force" ]; then
    echo -e "\n${RED}Performing destructive context reset...${NC}"
    
    # Reset multiple active actions
    if [ -d ".aicheck/actions" ]; then
      find .aicheck/actions -name "status.txt" -exec sed -i "" 's/ActiveAction/Not Started/g' {} \; 2>/dev/null
      echo -e "${GREEN}âœ“ Reset all actions to 'Not Started'${NC}"
    fi
    
    # Reset current action
    echo "None" > .aicheck/current_action
    echo -e "${GREEN}âœ“ Reset current action to 'None'${NC}"
    
    echo -e "${RED}âš  Destructive context reset completed${NC}"
    echo -e "${YELLOW}You may need to manually restore your intended active action${NC}"
  fi
  
  echo -e "\n${GREEN}âœ“ Context cleanup completed${NC}"
}

# Function to automatically compact context (summarize and preserve essentials)
function compact_context() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Context Compact${NC}"
  echo -e "Compacting context for action: ${GREEN}$current_action${NC}"
  
  if [ "$current_action" = "None" ] || [ "$current_action" = "AICheckExec" ]; then
    echo -e "${YELLOW}No active action to compact${NC}"
    return 0
  fi
  
  local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir=".aicheck/actions/$dir_name"
  
  if [ ! -d "$action_dir" ]; then
    echo -e "${RED}Action directory not found: $action_dir${NC}"
    return 1
  fi
  
  # Automated compaction (no approval needed)
  echo -e "\n${BRIGHT_BLURPLE}Performing automated compaction...${NC}"
  
  # Create compact summary
  local timestamp=$(date +"%Y-%m-%d_%H%M%S")
  local summary_file="$action_dir/context-compact-$timestamp.md"
  
  cat > "$summary_file" << COMPACT
# Context Compact: $current_action

**Generated:** $(date)
**Action Status:** $(cat "$action_dir/status.txt" 2>/dev/null || echo "Unknown")

## Action Summary

$(head -20 "$action_dir/$dir_name-plan.md" 2>/dev/null || echo "Plan not found")

## Recent Progress

$(tail -10 "$action_dir/progress.md" 2>/dev/null || echo "No progress logged")

## Key Files Modified (Last 24h)

$(if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  git log --since="24 hours ago" --name-only --pretty=format: | sort -u | head -10
else
  echo "Not in git repository"
fi)

## Dependencies

$(if [ -f "documentation/dependencies/dependency_index.md" ]; then
  grep "$current_action" documentation/dependencies/dependency_index.md || echo "No dependencies found"
else
  echo "No dependency index found"
fi)

## Context State

- Interaction logs: $(find "$action_dir/supporting_docs/claude-interactions" -name "*.md" 2>/dev/null | wc -l | tr -d ' ') files
- Git changes: $(git status --porcelain 2>/dev/null | wc -l | tr -d ' ') files
- Action progress: $(grep "Progress:" "$action_dir/$dir_name-plan.md" 2>/dev/null | cut -d':' -f2 | tr -d ' ' || echo "Unknown")
COMPACT

  echo -e "${GREEN}âœ“ Created compact summary: $(basename "$summary_file")${NC}"
  
  # Archive older interaction logs (keep last 3)
  local interaction_dir="$action_dir/supporting_docs/claude-interactions"
  if [ -d "$interaction_dir" ]; then
    local log_count=$(ls "$interaction_dir"/*.md 2>/dev/null | wc -l | tr -d ' ')
    if [ "$log_count" -gt 3 ]; then
      mkdir -p "$interaction_dir/archive"
      ls -t "$interaction_dir"/*.md 2>/dev/null | tail -n +4 | xargs mv -t "$interaction_dir/archive/" 2>/dev/null || true
      echo -e "${GREEN}âœ“ Archived $(($log_count - 3)) older interaction logs${NC}"
    fi
  fi
  
  # Update progress tracking
  local current_progress=$(grep "Progress:" "$action_dir/$dir_name-plan.md" 2>/dev/null | cut -d':' -f2 | tr -d ' %' || echo "0")
  echo "$(date +"%Y-%m-%d") - Context compacted (Progress: $current_progress%)" >> "$action_dir/progress.md"
  
  echo -e "${GREEN}âœ“ Context compaction completed${NC}"
  echo -e "${BRIGHT_BLURPLE}Summary: $summary_file${NC}"
}

# Function to track and analyze usage costs
function analyze_usage_costs() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Usage & Cost Analysis${NC}"
  echo -e "Current Action: ${GREEN}$current_action${NC}"
  
  # Track interaction frequency and estimate costs
  local total_interactions=0
  local today_interactions=0
  local thinking_usage=0
  local estimated_cost=0
  
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    local interaction_dir=".aicheck/actions/$dir_name/supporting_docs/claude-interactions"
    
    if [ -d "$interaction_dir" ]; then
      total_interactions=$(find "$interaction_dir" -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
      today_interactions=$(find "$interaction_dir" -name "*.md" -mtime -1 2>/dev/null | wc -l | tr -d ' ')
      
      # Analyze for "think harder" usage patterns
      thinking_usage=$(find "$interaction_dir" -name "*.md" -exec grep -l "think\|analyze\|complex" {} \; 2>/dev/null | wc -l | tr -d ' ')
    fi
  fi
  
  # Estimate costs based on Claude Code subscription model
  # Rough estimation: Claude Code subscription provides predictable costs
  local daily_limit=100
  local usage_percent=$((today_interactions * 100 / daily_limit))
  
  echo -e "\n${BRIGHT_BLURPLE}Usage Statistics:${NC}"
  echo -e "Total interactions: ${GREEN}$total_interactions${NC}"
  echo -e "Today's interactions: ${GREEN}$today_interactions${NC}"
  echo -e "Thinking-intensive: ${GREEN}$thinking_usage${NC} ($(($thinking_usage * 100 / ($total_interactions + 1)))%)"
  echo -e "Daily usage: ${GREEN}$usage_percent%${NC} of typical daily limit"
  
  # Context size analysis
  local context_files=$(find . -name "*.md" -o -name "*.js" -o -name "*.py" -o -name "*.ts" | wc -l | tr -d ' ')
  local large_files=$(find . -name "*.md" -o -name "*.js" -o -name "*.py" -o -name "*.ts" -size +10k | wc -l | tr -d ' ')
  
  echo -e "\n${BRIGHT_BLURPLE}Context Optimization:${NC}"
  echo -e "Total context files: ${GREEN}$context_files${NC}"
  echo -e "Large files (>10k): ${YELLOW}$large_files${NC}"
  
  if [ "$large_files" -gt 5 ]; then
    echo -e "${YELLOW}âš  Consider context optimization for large files${NC}"
  fi
  
  # Usage recommendations
  echo -e "\n${BRIGHT_BLURPLE}Optimization Recommendations:${NC}"
  
  if [ "$usage_percent" -gt 80 ]; then
    echo -e "${YELLOW}â€¢ High daily usage - consider context compaction${NC}"
    echo -e "${YELLOW}â€¢ Run './aicheck context compact' to reduce context size${NC}"
  fi
  
  if [ "$thinking_usage" -gt 5 ]; then
    echo -e "${YELLOW}â€¢ High thinking usage - consider graduated prompts${NC}"
    echo -e "${YELLOW}â€¢ Start with simple prompts, escalate to 'think harder' only when needed${NC}"
  fi
  
  if [ "$large_files" -gt 3 ]; then
    echo -e "${YELLOW}â€¢ Large context detected - consider file splitting${NC}"
    echo -e "${YELLOW}â€¢ Use surgical fix templates for focused changes${NC}"
  fi
  
  echo -e "${GREEN}âœ“ Usage analysis completed${NC}"
}

# Function to auto-cleanup after commits
function auto_post_commit_cleanup() {
  echo -e "${BRIGHT_BLURPLE}ðŸ¤– Auto-cleanup after commit detected...${NC}"
  
  # Check if there are recent commits (last 10 minutes)
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local recent_commits=$(git log --since="10 minutes ago" --oneline 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$recent_commits" -gt 0 ]; then
      echo -e "${GREEN}âœ“ Recent commit detected, running comprehensive cleanup...${NC}"
      
      # Run full optimization
      optimize_context
      
      # Validate dependencies and documentation
      validate_action_completeness
      
      return 0
    fi
  fi
  
  return 1
}

# Function to validate action completeness and RULES compliance
function validate_action_completeness() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$current_action" = "None" ] || [ "$current_action" = "AICheckExec" ]; then
    return 0
  fi
  
  echo -e "\n${BRIGHT_BLURPLE}ðŸ” Validating RULES compliance and action completeness...${NC}"
  
  local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir=".aicheck/actions/$dir_name"
  local issues=()
  local auto_fixes=()
  
  # 1. RULES: Check action status and matrix updates
  echo -e "${BRIGHT_BLURPLE}ðŸ“‹ Checking action status compliance...${NC}"
  
  if [ ! -f "$action_dir/status.txt" ]; then
    issues+=("Action status file missing")
    auto_fixes+=("create_status_file")
  fi
  
  # Verify actions_index.md is current
  if [ -f ".aicheck/actions_index.md" ]; then
    if ! grep -q "$current_action" .aicheck/actions_index.md; then
      issues+=("Action not registered in actions_index.md")
      auto_fixes+=("update_actions_index")
    fi
  fi
  
  # 2. RULES: Check action timeline and progress tracking
  echo -e "${BRIGHT_BLURPLE}ðŸ“ˆ Checking timeline and progress compliance...${NC}"
  
  if [ ! -f "$action_dir/progress.md" ]; then
    issues+=("Progress tracking missing: $action_dir/progress.md")
    auto_fixes+=("create_progress_tracking")
  else
    # Check if progress has been updated recently
    local last_update=$(stat -f "%m" "$action_dir/progress.md" 2>/dev/null || stat -c "%Y" "$action_dir/progress.md" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_update))
    if [ "$time_diff" -gt 86400 ]; then  # 24 hours
      issues+=("Progress tracking not updated in 24+ hours")
      auto_fixes+=("update_progress_timestamp")
    fi
  fi
  
  # 3. RULES: Check dependency documentation
  echo -e "${BRIGHT_BLURPLE}ðŸ”— Checking dependency compliance...${NC}"
  
  # Check for code dependencies that aren't documented
  if git status --porcelain 2>/dev/null | grep -q "package.json\|requirements.txt\|go.mod\|Cargo.toml\|pom.xml\|build.gradle"; then
    if ! grep -q "$current_action" documentation/dependencies/dependency_index.md 2>/dev/null; then
      issues+=("Dependencies modified but not documented for $current_action")
    fi
  fi
  
  # Check for import statements in modified files
  local modified_files=$(git status --porcelain 2>/dev/null | awk '{print $2}')
  local has_imports=false
  for file in $modified_files; do
    if [[ "$file" =~ \.(py|js|ts|jsx|tsx)$ ]] && [ -f "$file" ]; then
      if grep -q "^import\|^from.*import\|require(" "$file" 2>/dev/null; then
        has_imports=true
        break
      fi
    fi
  done
  
  if [ "$has_imports" = true ] && ! grep -q "$current_action" documentation/dependencies/dependency_index.md 2>/dev/null; then
    issues+=("Code imports detected but dependencies not documented")
  fi
  
  # 4. RULES: Check action plan compliance
  echo -e "${BRIGHT_BLURPLE}ðŸ“ Checking action plan compliance...${NC}"
  
  if [ ! -f "$action_dir/$dir_name-plan.md" ]; then
    issues+=("Action plan missing: $action_dir/$dir_name-plan.md")
    auto_fixes+=("create_action_plan")
  else
    # Check plan has required sections
    local plan_file="$action_dir/$dir_name-plan.md"
    if ! grep -q "## Purpose" "$plan_file"; then
      issues+=("Action plan missing Purpose section")
    fi
    if ! grep -q "## Requirements" "$plan_file"; then
      issues+=("Action plan missing Requirements section") 
    fi
    if ! grep -q "## Success Criteria" "$plan_file"; then
      issues+=("Action plan missing Success Criteria section")
    fi
    if ! grep -q "Progress:" "$plan_file"; then
      issues+=("Action plan missing Progress tracking")
      auto_fixes+=("add_progress_to_plan")
    fi
  fi
  
  # 5. RULES: Check Claude interaction logging
  echo -e "${BRIGHT_BLURPLE}ðŸ’¬ Checking Claude interaction compliance...${NC}"
  
  local interaction_dir="$action_dir/supporting_docs/claude-interactions"
  if [ ! -d "$interaction_dir" ] || [ $(find "$interaction_dir" -name "*.md" 2>/dev/null | wc -l) -eq 0 ]; then
    issues+=("No Claude interactions logged for $current_action")
    auto_fixes+=("create_interaction_structure")
  fi
  
  # 6. RULES: Check documentation migration for completed features
  if [ -f "$action_dir/status.txt" ] && grep -q "Completed" "$action_dir/status.txt"; then
    echo -e "${BRIGHT_BLURPLE}ðŸ“š Checking documentation migration for completed action...${NC}"
    
    # Check if documentation has been migrated to central docs
    if [ ! -f "documentation/api/actions-completed.md" ]; then
      auto_fixes+=("create_completed_docs")
    fi
  fi
  
  # 7. RULES: Check test compliance
  echo -e "${BRIGHT_BLURPLE}ðŸ§ª Checking test compliance...${NC}"
  
  # Look for implementation files without corresponding tests
  local impl_files=$(git status --porcelain 2>/dev/null | awk '{print $2}' | grep -E "\.(py|js|ts|jsx|tsx)$" | grep -v test | grep -v spec)
  if [ -n "$impl_files" ]; then
    local has_tests=false
    for file in $impl_files; do
      local test_file1="${file%.*}.test.${file##*.}"
      local test_file2="${file%.*}_test.${file##*.}"
      local test_file3="tests/$(basename "${file%.*}").test.${file##*.}"
      if [ -f "$test_file1" ] || [ -f "$test_file2" ] || [ -f "$test_file3" ]; then
        has_tests=true
        break
      fi
    done
    
    if [ "$has_tests" = false ]; then
      issues+=("Implementation files modified without corresponding tests")
    fi
  fi
  
  # Report issues and perform auto-fixes
  if [ ${#issues[@]} -gt 0 ]; then
    echo -e "${YELLOW}âš  Found ${#issues[@]} RULES compliance issues:${NC}"
    printf '  - %s\n' "${issues[@]}"
    
    echo -e "\n${BRIGHT_BLURPLE}ðŸ”§ Auto-fixing compliance issues...${NC}"
    
    # Perform auto-fixes
    for fix in "${auto_fixes[@]}"; do
      case $fix in
        "create_status_file")
          echo "ActiveAction" > "$action_dir/status.txt"
          echo -e "${GREEN}âœ“ Created status file${NC}"
          ;;
        "create_progress_tracking")
          # Get action info for MCP header
          local action_info=$(get_mcp_action_info)
          local action_id=$(echo "$action_info" | cut -d'|' -f1)
          local datetime=$(echo "$action_info" | cut -d'|' -f2)
          
          cat > "$action_dir/progress.md" << PROGRESS
<!-- MCP: AICheck_Tracker -->
<!-- Action: $action_id -->
<!-- DateTime: $datetime -->
<!-- Task: Track progress for $current_action -->
<!-- File: progress.md -->
<!-- Track progress and document decisions as you work. -->
<!-- Update task status and log any blockers or dependencies. -->

# $current_action Progress

## Updates

$(date +"%Y-%m-%d") - Auto-created progress tracking for RULES compliance
$(date +"%Y-%m-%d") - Action status: $(cat "$action_dir/status.txt" 2>/dev/null || echo "ActiveAction")

## Timeline

- $(date +"%Y-%m-%d"): Action created/reactivated
- Next update: [Track your progress here]

## Tasks

- [ ] Update this file with your progress
- [ ] Document any dependencies added  
- [ ] Update action plan if scope changes
- [ ] Ensure tests are written before implementation
- [ ] Log Claude interactions as you work

## Dependencies Added

[Document any new dependencies here]

## Documentation Migration

[Track any documentation that needs to be moved to central docs]

PROGRESS
          echo -e "${GREEN}âœ“ Created RULES-compliant progress tracking${NC}"
          ;;
        "create_action_plan")
          # Get action info for MCP header
          local action_info=$(get_mcp_action_info)
          local action_id=$(echo "$action_info" | cut -d'|' -f1)
          local datetime=$(echo "$action_info" | cut -d'|' -f2)
          
          cat > "$action_dir/$dir_name-plan.md" << PLAN
<!-- MCP: AICheck_Planner -->
<!-- Action: $action_id -->
<!-- DateTime: $datetime -->
<!-- Task: Implement $current_action -->
<!-- File: $dir_name-plan.md -->
<!-- Before coding, outline the steps you plan to take to complete this task. -->
<!-- Follow the approved action plan and document any scope changes. -->

# ACTION: $current_action

Version: 1.0
Last Updated: $(date +"%Y-%m-%d")
Status: ActiveAction
Progress: 0%

## Purpose

[Describe the purpose of this ACTION and its value to the PROGRAM]

## Requirements

- [Requirement 1]
- [Requirement 2]

## Dependencies

- [Document any dependencies here]

## Implementation Approach

### Phase 1: Research and Planning
- [Research tasks]

### Phase 2: Test Design
- [Test specifications and cases]

### Phase 3: Implementation  
- [Implementation tasks]

### Phase 4: Documentation
- [Documentation and migration tasks]

## Success Criteria

- [Criterion 1: Tests pass]
- [Criterion 2: Documentation complete]
- [Criterion 3: Dependencies documented]

## Timeline

- Start: $(date +"%Y-%m-%d")
- Target completion: [Set target date]

PLAN
          echo -e "${GREEN}âœ“ Created RULES-compliant action plan${NC}"
          ;;
        "create_interaction_structure")
          mkdir -p "$interaction_dir"
          cat > "$interaction_dir/README.md" << INTERACTIONS
# Claude Interactions for $current_action

This directory contains all Claude Code interactions for this action.

## RULES Compliance

- All Claude interactions must be logged here
- Include purpose, date, and content for each interaction
- Interactions help track decision-making process
- Required for action completion verification

## File Naming

Use format: YYYY-MM-DD_HHMMSS-purpose.md

INTERACTIONS
          echo -e "${GREEN}âœ“ Created Claude interactions structure${NC}"
          ;;
        "update_actions_index")
          # Add action to index if not present
          if [ -f ".aicheck/actions_index.md" ]; then
            if ! grep -q "$current_action" .aicheck/actions_index.md; then
              local line_num=$(grep -n "| \*None yet\* |" .aicheck/actions_index.md | head -1 | cut -d':' -f1)
              if [ -n "$line_num" ]; then
                sed -i "" "${line_num}s/| \*None yet\* | | | | |/| $current_action | | ActiveAction | 0% | |\\n| \*None yet\* | | | | |/" .aicheck/actions_index.md
                echo -e "${GREEN}âœ“ Updated actions index${NC}"
              fi
            fi
          fi
          ;;
        "add_progress_to_plan")
          if [ -f "$action_dir/$dir_name-plan.md" ] && ! grep -q "Progress:" "$action_dir/$dir_name-plan.md"; then
            sed -i "" '/^Status:/a\
Progress: 0%' "$action_dir/$dir_name-plan.md"
            echo -e "${GREEN}âœ“ Added progress tracking to plan${NC}"
          fi
          ;;
        "update_progress_timestamp")
          echo "$(date +"%Y-%m-%d") - Progress check during cleanup validation" >> "$action_dir/progress.md"
          echo -e "${GREEN}âœ“ Updated progress timestamp${NC}"
          ;;
        "create_completed_docs")
          mkdir -p documentation/api
          if [ ! -f "documentation/api/actions-completed.md" ]; then
            cat > "documentation/api/actions-completed.md" << COMPLETED
# Completed Actions Documentation

This file tracks completed actions and their documentation migration.

## Completed Actions

### $current_action
- Completion Date: $(date +"%Y-%m-%d")
- Documentation Location: [Link to migrated docs]
- Key Deliverables: [List main outputs]

COMPLETED
            echo -e "${GREEN}âœ“ Created completed actions documentation${NC}"
          fi
          ;;
      esac
    done
    
    # Update actions index timestamp
    if [ -f ".aicheck/actions_index.md" ]; then
      sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
    fi
    
    echo -e "${YELLOW}Manual fixes still needed:${NC}"
    echo -e "${YELLOW}â€¢ Document dependencies: ./aicheck dependency add NAME VERSION JUSTIFICATION${NC}"
    echo -e "${YELLOW}â€¢ Write tests before implementation (RULES requirement)${NC}"
    echo -e "${YELLOW}â€¢ Log Claude interactions during work${NC}"
    echo -e "${YELLOW}â€¢ Update action plan with specific requirements${NC}"
    echo -e "${YELLOW}â€¢ Migrate documentation to central folders when action completes${NC}"
  else
    echo -e "${GREEN}âœ“ Full RULES compliance verified${NC}"
  fi
}

# Function to optimize context for cost efficiency
function optimize_context() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Context Optimization${NC}"
  echo -e "Optimizing for cost efficiency and performance..."
  
  # Automated optimization (no approval needed)
  echo -e "\n${BRIGHT_BLURPLE}Performing automated optimizations...${NC}"
  
  # Compress old interaction logs
  if [ -d ".aicheck" ]; then
    find .aicheck -name "claude-interactions" -type d | while read dir; do
      if [ $(find "$dir" -name "*.md" 2>/dev/null | wc -l) -gt 10 ]; then
        mkdir -p "$dir/compressed"
        # Move old interactions to compressed folder
        find "$dir" -name "*.md" -mtime +7 | head -n -5 | while read file; do
          mv "$file" "$dir/compressed/" 2>/dev/null || true
        done
      fi
    done
    echo -e "${GREEN}âœ“ Compressed old interaction logs${NC}"
  fi
  
  # Generate context summary for large files
  local summary_file=".aicheck/context-summary-$(date +%Y%m%d).md"
  cat > "$summary_file" << SUMMARY
# Context Summary - $(date)

## Project Overview
$(head -20 README.md 2>/dev/null || echo "No README found")

## Current Action
$(cat .aicheck/current_action 2>/dev/null || echo "None")

## Active Files (Modified in last 7 days)
$(find . -name "*.js" -o -name "*.py" -o -name "*.ts" -o -name "*.md" -mtime -7 2>/dev/null | head -20)

## Key Dependencies
$(if [ -f "package.json" ]; then jq -r '.dependencies | keys[]' package.json 2>/dev/null | head -10; fi)
$(if [ -f "requirements.txt" ]; then head -10 requirements.txt 2>/dev/null; fi)

## Recent Changes
$(git log --oneline -10 2>/dev/null || echo "No git history")

*This summary can be used instead of reading many individual files to understand project context*
SUMMARY
  
  echo -e "${GREEN}âœ“ Generated context summary: $(basename "$summary_file")${NC}"
  
  # Cache frequently accessed patterns
  local cache_file=".aicheck/pattern-cache-$(date +%Y%m%d).md"
  cat > "$cache_file" << CACHE
# Frequently Used Patterns Cache

## Code Patterns
$(grep -r "function\|class\|const\|def " --include="*.js" --include="*.py" --include="*.ts" . 2>/dev/null | head -20)

## Import Patterns  
$(grep -r "import\|require\|from " --include="*.js" --include="*.py" --include="*.ts" . 2>/dev/null | head -15)

## Test Patterns
$(find . -name "*test*" -o -name "*spec*" -name "*.js" -o -name "*.py" -o -name "*.ts" 2>/dev/null | head -10)

*Cache generated: $(date)*
CACHE
  
  echo -e "${GREEN}âœ“ Cached common patterns for quick reference${NC}"
  
  # Analyze context efficiency
  local total_size=$(du -sh . 2>/dev/null | cut -f1)
  local aicheck_size=$(du -sh .aicheck 2>/dev/null | cut -f1)
  
  echo -e "\n${BRIGHT_BLURPLE}Context Efficiency Report:${NC}"
  echo -e "Total project size: ${GREEN}$total_size${NC}"
  echo -e "AICheck overhead: ${GREEN}$aicheck_size${NC}"
  echo -e "Optimization files created: ${GREEN}2${NC}"
  
  echo -e "\n${GREEN}âœ“ Context optimization completed${NC}"
  echo -e "${BRIGHT_BLURPLE}Use context summary and pattern cache for efficient prompting${NC}"
}

# Function to automatically enforce action boundaries
function enforce_action_boundaries() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$current_action" = "None" ] || [ "$current_action" = "AICheckExec" ]; then
    echo -e "${YELLOW}No active action - boundary enforcement skipped${NC}"
    return 0
  fi
  
  echo -e "${BRIGHT_BLURPLE}Enforcing boundaries for: ${GREEN}$current_action${NC}"
  
  local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir=".aicheck/actions/$dir_name"
  
  # Check for scope creep indicators
  local scope_warnings=()
  
  # Check if working outside action directory
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local changed_files=$(git status --porcelain 2>/dev/null | awk '{print $2}')
    local outside_scope=0
    
    for file in $changed_files; do
      # Skip if file is in action directory or common project files
      if [[ ! "$file" =~ ^\.aicheck/actions/$dir_name/ ]] && 
         [[ ! "$file" =~ ^(src/|tests/|documentation/|README|\.md$) ]]; then
        outside_scope=$((outside_scope + 1))
      fi
    done
    
    if [ "$outside_scope" -gt 0 ]; then
      scope_warnings+=("$outside_scope files modified outside expected scope")
    fi
  fi
  
  # Check for excessive new dependencies
  if [ -f "documentation/dependencies/dependency_index.md" ]; then
    local recent_deps=$(grep "$(date +"%Y-%m-%d")" documentation/dependencies/dependency_index.md | grep "$current_action" | wc -l | tr -d ' ')
    if [ "$recent_deps" -gt 3 ]; then
      scope_warnings+=("$recent_deps new dependencies added today")
    fi
  fi
  
  # Check for multiple action modifications
  local modified_actions=$(find .aicheck/actions -name "*.md" -newer .aicheck/current_action 2>/dev/null | grep -v "$dir_name" | wc -l | tr -d ' ')
  if [ "$modified_actions" -gt 0 ]; then
    scope_warnings+=("$modified_actions other actions modified during this session")
  fi
  
  if [ ${#scope_warnings[@]} -gt 0 ]; then
    echo -e "${YELLOW}âš  Potential scope creep detected:${NC}"
    printf '  - %s\n' "${scope_warnings[@]}"
    echo -e "${YELLOW}Consider using './aicheck context clear' if work has drifted${NC}"
    return 1
  else
    echo -e "${GREEN}âœ“ Action boundaries maintained${NC}"
    return 0
  fi
}

# Function to detect if this is a new session and auto-run stuck command
function auto_session_start_check() {
  # Check if this appears to be a new session by looking for recent activity
  local session_marker=".aicheck/last_session_timestamp"
  local current_time=$(date +%s)
  local session_gap=3600  # 1 hour gap indicates new session
  
  # Create .aicheck directory if it doesn't exist
  mkdir -p .aicheck
  
  # Check if we have a previous session timestamp
  if [ -f "$session_marker" ]; then
    local last_session=$(cat "$session_marker" 2>/dev/null || echo "0")
    local time_diff=$((current_time - last_session))
    
    if [ "$time_diff" -gt "$session_gap" ]; then
      echo -e "${BRIGHT_BLURPLE}ðŸ†• New session detected (${time_diff}s gap)${NC}"
      echo -e "${BRIGHT_BLURPLE}ðŸ¤– Auto-running session startup checks...${NC}"
      
      # Update session timestamp
      echo "$current_time" > "$session_marker"
      
      # Run stuck command logic without the full UI (simplified for robustness)
      echo -e "${YELLOW}Session Summary:${NC}"
      local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      echo -e "Current Action: ${GREEN}$current_action${NC}"
      
      # Check for basic issues (simplified)
      local pollution_score=0
      if [ -d ".aicheck/actions" ]; then
        local active_count=$(find .aicheck/actions -name "status.txt" -exec grep -l "ActiveAction" {} \; 2>/dev/null | wc -l | tr -d ' ')
        if [ "$active_count" -gt 1 ]; then
          pollution_score=30
        fi
      fi
      
      if [ "$pollution_score" -gt 30 ]; then
        echo -e "${YELLOW}âš  Context pollution detected${NC}"
        echo -e "${YELLOW}Consider running './aicheck cleanup' before starting work${NC}"
      fi
      
      echo -e "${GREEN}âœ“ Session startup complete${NC}"
      return 0
    fi
  fi
  
  # Update session timestamp for normal commands
  echo "$current_time" > "$session_marker"
  return 1
}

# Function to auto-run focus check before new actions
function auto_focus_check() {
  echo -e "${BRIGHT_BLURPLE}ðŸ¤– Auto-checking focus before creating new action...${NC}"
  
  # Check if there's an active action
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    echo -e "${YELLOW}âš  You have an active action: $current_action${NC}"
    
    # Auto-check boundaries
    if ! enforce_action_boundaries >/dev/null 2>&1; then
      echo -e "${YELLOW}ðŸŽ¯ Scope creep detected in current action!${NC}"
      echo -e "${YELLOW}Consider completing '$current_action' first or running './aicheck focus' for details${NC}"
      echo -e "${YELLOW}Continue creating new action anyway? (y/n)${NC}"
      read -r continue_anyway
      
      if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
        echo -e "${YELLOW}Action creation cancelled. Fix current action first.${NC}"
        return 1
      fi
    else
      echo -e "${GREEN}âœ“ Current action boundaries look good${NC}"
    fi
  fi
  
  # Check context pollution
  local pollution_data=$(detect_context_pollution)
  local pollution_score=$(echo "$pollution_data" | head -1)
  
  if [ "$pollution_score" -gt 30 ]; then
    echo -e "${YELLOW}âš  Context pollution detected (score: $pollution_score)${NC}"
    echo -e "${YELLOW}Recommend running './aicheck cleanup' before starting new work${NC}"
    echo -e "${YELLOW}Continue anyway? (y/n)${NC}"
    read -r continue_anyway
    
    if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
      echo -e "${YELLOW}Action creation cancelled. Clean up context first.${NC}"
      return 1
    fi
  fi
  
  echo -e "${GREEN}âœ“ Focus check passed${NC}"
  return 0
}

# Function to create a new action
function create_action() {
  local action_name=$1
  
  if [ -z "$action_name" ]; then
    echo -e "${RED}Error: Action name is required${NC}"
    echo "Usage: ./aicheck action new ACTION_NAME"
    exit 1
  fi
  
  # Auto-run focus check before creating action
  if ! auto_focus_check; then
    return 1
  fi
  
  # Convert PascalCase to kebab-case for directories (compatible with macOS)
  local dir_name=$(echo "$action_name" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  # Create action directory
  mkdir -p ".aicheck/actions/$dir_name"
  mkdir -p ".aicheck/actions/$dir_name/supporting_docs/claude-interactions"
  mkdir -p ".aicheck/actions/$dir_name/supporting_docs/process-tests"
  mkdir -p ".aicheck/actions/$dir_name/supporting_docs/research"
  
  # Create plan file
  # Get action info for MCP header
  local action_info=$(get_mcp_action_info)
  local action_id=$(echo "$action_info" | cut -d'|' -f1)
  local datetime=$(echo "$action_info" | cut -d'|' -f2)
  
  cat > ".aicheck/actions/$dir_name/$dir_name-plan.md" << PLAN
<!-- MCP: AICheck_Planner -->
<!-- Action: $action_id -->
<!-- DateTime: $datetime -->
<!-- Task: Implement $action_name -->
<!-- File: $dir_name-plan.md -->
<!-- Before coding, outline the steps you plan to take to complete this task. -->
<!-- Follow the approved action plan and document any scope changes. -->

# ACTION: $action_name

Version: 1.0
Last Updated: $(date +"%Y-%m-%d")
Status: Not Started
Progress: 0%

## Purpose

[Describe the purpose of this ACTION and its value to the PROGRAM]

## Requirements

- [Requirement 1]
- [Requirement 2]

## Dependencies

- [Dependency 1, if any]

## Implementation Approach

### Phase 1: Research

- [Research task 1]
- [Research task 2]

### Phase 2: Design

- [Design task 1]
- [Design task 2]

### Phase 3: Implementation

- [Implementation task 1]
- [Implementation task 2]

### Phase 4: Testing

- [Test case 1]
- [Test case 2]

## Success Criteria

- [Criterion 1]
- [Criterion 2]

## Estimated Timeline

- Research: [X days]
- Design: [X days]
- Implementation: [X days]
- Testing: [X days]
- Total: [X days]

## Notes

[Any additional notes or considerations]
PLAN
  
  # Create status file
  echo "Not Started" > ".aicheck/actions/$dir_name/status.txt"
  
  # Create progress file
  # Get action info for MCP header  
  local action_info=$(get_mcp_action_info)
  local action_id=$(echo "$action_info" | cut -d'|' -f1)
  local datetime=$(echo "$action_info" | cut -d'|' -f2)
  
  echo "<!-- MCP: AICheck_Tracker -->
<!-- Action: $action_id -->
<!-- DateTime: $datetime -->
<!-- Task: Track progress for $action_name -->
<!-- File: progress.md -->
<!-- Track progress and document decisions as you work. -->
<!-- Update task status and log any blockers or dependencies. -->

# $action_name Progress

## Updates

$(date +"%Y-%m-%d") - Action created

## Tasks

- [ ] Research phase
- [ ] Design phase
- [ ] Implementation phase
- [ ] Testing phase
- [ ] Documentation
" > ".aicheck/actions/$dir_name/progress.md"
  
  # Update actions_index.md
  # Get the line number of the "Active Actions" table's end
  line_num=$(grep -n "\| \*None yet\* \| \| \| \| \|" .aicheck/actions_index.md | cut -d':' -f1)
  
  if [ -n "$line_num" ]; then
    # Replace the "None yet" line with the new action
    sed -i "" "$line_num s/| \*None yet\* | | | | |/| $action_name | | Not Started | 0% | |\n| \*None yet\* | | | | |/" .aicheck/actions_index.md
  else
    # Append to the Active Actions table
    line_num=$(grep -n "## Active Actions" .aicheck/actions_index.md | cut -d':' -f1)
    if [ -n "$line_num" ]; then
      awk -v line="$line_num" -v action="| $action_name | | Not Started | 0% | |" 'NR==line+4{print action}1' .aicheck/actions_index.md > .aicheck/actions_index.md.tmp
      mv .aicheck/actions_index.md.tmp .aicheck/actions_index.md
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  
  echo -e "${GREEN}âœ“ Created new ACTION: $action_name${NC}"
  echo -e "${BRIGHT_BLURPLE}Directory: .aicheck/actions/$dir_name${NC}"
  echo -e "${YELLOW}NOTE: This ACTION requires planning and approval before implementation${NC}"
}

# Function to set the active action
function set_active_action() {
  local action_name=$1
  
  if [ -z "$action_name" ]; then
    echo -e "${RED}Error: Action name is required${NC}"
    echo "Usage: ./aicheck action set ACTION_NAME"
    exit 1
  fi
  
  # Convert PascalCase to kebab-case for directories (compatible with macOS)
  local dir_name=$(echo "$action_name" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  # Check if action exists
  if [ ! -d ".aicheck/actions/$dir_name" ]; then
    echo -e "${RED}Error: Action '$action_name' does not exist${NC}"
    echo "Available actions:"
    ls -1 .aicheck/actions/ | grep -v "README"
    exit 1
  fi
  
  # ENFORCE: First deactivate ALL other actions to ensure only one active
  echo -e "${BLUE}Enforcing single active action rule...${NC}"
  
  # Find all ActiveAction entries and change them to their previous status
  for action_dir in .aicheck/actions/*/; do
    if [ -d "$action_dir" ]; then
      local status_file="$action_dir/status.txt"
      if [ -f "$status_file" ] && [ "$(cat "$status_file")" = "ActiveAction" ]; then
        # Set to "In Progress" as default previous state
        echo "In Progress" > "$status_file"
      fi
    fi
  done
  
  # Update actions_index.md - change all ActiveAction/Active to In Progress
  sed -i "" 's/| \(.*\) | \(.*\) | ActiveAction | \(.*\) | \(.*\) |/| \1 | \2 | In Progress | \3 | \4 |/g' .aicheck/actions_index.md
  sed -i "" 's/| \(.*\) | \(.*\) | Active | \(.*\) | \(.*\) |/| \1 | \2 | In Progress | \3 | \4 |/g' .aicheck/actions_index.md
  
  # Set as current action
  echo "$action_name" > .aicheck/current_action
  
  # Update this action's status to ActiveAction
  echo "ActiveAction" > ".aicheck/actions/$dir_name/status.txt"
  
  # Update actions_index.md for this specific action
  sed -i "" "s/| $action_name | \(.*\) | [^|]* | \(.*\) | \(.*\) |/| $action_name | \1 | ActiveAction | \2 | \3 |/" .aicheck/actions_index.md
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  
  # Verify enforcement worked
  local active_count=$(grep -c "| .* | .* | Active\(Action\)\? | .* | .* |" .aicheck/actions_index.md 2>/dev/null | tr -d '\n')
  active_count=${active_count:-0}
  if [ "$active_count" -ne 1 ]; then
    echo -e "${RED}WARNING: Multiple active actions detected!${NC}"
    echo -e "${YELLOW}This violates AICheck single-action principle${NC}"
  fi
  
  echo -e "${GREEN}âœ“ Set current action to: $action_name${NC}"
  echo -e "${CYAN}  All other actions marked as 'In Progress' or 'Not Started'${NC}"
}

# Function to detect project type and available tools
function detect_project_environment() {
  local project_info=()
  
  # Python detection
  if [ -f "pyproject.toml" ]; then
    project_info+=("python-poetry")
    [ -f "poetry.lock" ] && project_info+=("poetry-lock")
  elif [ -f "requirements.txt" ] || [ -f "requirements-dev.txt" ]; then
    project_info+=("python-pip")
  elif [ -f "setup.py" ] || [ -f "setup.cfg" ]; then
    project_info+=("python-setuptools")
  fi
  
  # Node.js detection
  if [ -f "package.json" ]; then
    project_info+=("node")
    [ -f "package-lock.json" ] && project_info+=("npm-lock")
    [ -f "yarn.lock" ] && project_info+=("yarn-lock")
    [ -f "pnpm-lock.yaml" ] && project_info+=("pnpm-lock")
  fi
  
  # Build system detection
  [ -f "Makefile" ] && project_info+=("make")
  [ -f "Rakefile" ] && project_info+=("rake")
  [ -f "build.gradle" ] || [ -f "build.gradle.kts" ] && project_info+=("gradle")
  [ -f "pom.xml" ] && project_info+=("maven")
  
  # Testing framework detection
  [ -f "pytest.ini" ] || [ -f ".pytest.ini" ] || [ -f "setup.cfg" ] && grep -q "pytest" setup.cfg 2>/dev/null && project_info+=("pytest")
  [ -f "jest.config.js" ] || [ -f "jest.config.ts" ] && project_info+=("jest")
  [ -d "tests" ] || [ -d "test" ] || [ -d "__tests__" ] && project_info+=("tests-dir")
  
  # Linting/formatting detection
  [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f ".eslintrc.yml" ] && project_info+=("eslint")
  [ -f ".prettierrc" ] || [ -f ".prettierrc.js" ] || [ -f ".prettierrc.json" ] && project_info+=("prettier")
  [ -f ".flake8" ] || [ -f "setup.cfg" ] && grep -q "flake8" setup.cfg 2>/dev/null && project_info+=("flake8")
  [ -f "pyproject.toml" ] && grep -q "black" pyproject.toml 2>/dev/null && project_info+=("black")
  [ -f "pyproject.toml" ] && grep -q "ruff" pyproject.toml 2>/dev/null && project_info+=("ruff")
  
  # Type checking detection
  [ -f "mypy.ini" ] || [ -f ".mypy.ini" ] || ([ -f "pyproject.toml" ] && grep -q "mypy" pyproject.toml 2>/dev/null) && project_info+=("mypy")
  [ -f "tsconfig.json" ] && project_info+=("typescript")
  
  # CI/CD detection
  [ -f ".github/workflows/"*.yml ] || [ -f ".github/workflows/"*.yaml ] && project_info+=("github-actions")
  [ -f ".gitlab-ci.yml" ] && project_info+=("gitlab-ci")
  [ -f ".circleci/config.yml" ] && project_info+=("circleci")
  
  # Container detection
  [ -f "Dockerfile" ] || [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ] && project_info+=("docker")
  
  echo "${project_info[@]}"
}

# Function to read AICheck configuration
function read_aicheck_config() {
  local config_file=".aicheck.config"
  local config_key=$1
  local default_value=$2
  
  if [ -f "$config_file" ]; then
    # Simple config parser - just grep for uncommented lines
    local value=$(grep -E "^${config_key}\s*=" "$config_file" 2>/dev/null | cut -d'=' -f2 | tr -d ' "')
    echo "${value:-$default_value}"
  else
    echo "$default_value"
  fi
}

# Function to run appropriate checks based on detected environment
function run_smart_completion_checks() {
  local action_name=$1
  local dir_name=$2
  local failed_checks=0
  local project_env=($(detect_project_environment))
  
  # Read configuration
  local mode=$(read_aicheck_config "mode" "smart")
  local require_tests=$(read_aicheck_config "require_tests" "false")
  local require_linting=$(read_aicheck_config "require_linting" "false")
  
  echo -e "\n${BRIGHT_BLURPLE}ðŸ” Detected project environment:${NC}"
  echo -e "${CYAN}$(IFS=', '; echo "${project_env[*]}")${NC}\n"
  
  # Show mode if not default
  if [ "$mode" != "smart" ]; then
    echo -e "${CYAN}ðŸ“‹ Completion mode: $mode${NC}\n"
  fi
  
  # 1. Dependency Integrity Checks
  echo -e "${BRIGHT_BLURPLE}ðŸ“¦ Checking dependency integrity...${NC}"
  
  # Python checks
  if [[ " ${project_env[@]} " =~ " python-poetry " ]]; then
    echo -n "  Poetry lock file: "
    if [ ! -f "poetry.lock" ]; then
      echo -e "${RED}âœ— Missing${NC}"
      echo -e "  ${YELLOW}â†’ Run: poetry install${NC}"
      ((failed_checks++))
    elif poetry check >/dev/null 2>&1 && poetry lock --check >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“${NC}"
    else
      echo -e "${RED}âœ— Out of sync${NC}"
      echo -e "  ${YELLOW}â†’ Run: poetry lock${NC}"
      ((failed_checks++))
    fi
  elif [ -f "pyproject.toml" ] && [ ! -f "poetry.lock" ]; then
    echo "  ${YELLOW}âš  Poetry project without lock file${NC}"
    echo "  ${YELLOW}â†’ Run: poetry install to create poetry.lock${NC}"
    echo "  ${YELLOW}â†’ Lock files ensure reproducible deployments${NC}"
  fi
  
  # Node checks
  if [[ " ${project_env[@]} " =~ " node " ]]; then
    echo -n "  NPM dependencies: "
    if [[ " ${project_env[@]} " =~ " npm-lock " ]]; then
      if npm ls >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“${NC}"
      else
        echo -e "${RED}âœ— Issues found${NC}"
        echo -e "  ${YELLOW}â†’ Run: npm install${NC}"
        ((failed_checks++))
      fi
    elif [[ " ${project_env[@]} " =~ " yarn-lock " ]]; then
      if yarn check --integrity >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“${NC}"
      else
        echo -e "${RED}âœ— Integrity check failed${NC}"
        echo -e "  ${YELLOW}â†’ Run: yarn install${NC}"
        ((failed_checks++))
      fi
    fi
  fi
  
  # 2. Test Suite Checks
  echo -e "\n${BRIGHT_BLURPLE}ðŸ§ª Checking tests...${NC}"
  
  if [[ " ${project_env[@]} " =~ " pytest " ]] && command -v pytest >/dev/null 2>&1; then
    echo -n "  Python tests: "
    if pytest -x --tb=short -q >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ All tests pass${NC}"
    else
      echo -e "${RED}âœ— Tests failing${NC}"
      echo -e "  ${YELLOW}â†’ Fix failing tests before completing action${NC}"
      ((failed_checks++))
    fi
  elif [[ " ${project_env[@]} " =~ " make " ]] && grep -q "^test:" Makefile 2>/dev/null; then
    echo -n "  Make tests: "
    if make test >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ All tests pass${NC}"
    else
      echo -e "${RED}âœ— Tests failing${NC}"
      ((failed_checks++))
    fi
  elif [[ " ${project_env[@]} " =~ " node " ]] && grep -q '"test"' package.json 2>/dev/null; then
    echo -n "  NPM tests: "
    if npm test >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ All tests pass${NC}"
    else
      echo -e "${RED}âœ— Tests failing${NC}"
      ((failed_checks++))
    fi
  else
    echo "  ${YELLOW}âš  No test suite detected${NC}"
    echo "  ${YELLOW}â†’ Consider adding tests to verify code works before deployment${NC}"
    # This is a warning, not a failure - teams might have other verification methods
  fi
  
  # 3. Code Quality Checks
  echo -e "\n${BRIGHT_BLURPLE}âœ¨ Checking code quality...${NC}"
  
  # Python linting
  if [[ " ${project_env[@]} " =~ " black " ]] && command -v black >/dev/null 2>&1; then
    echo -n "  Black formatting: "
    if black --check . >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“${NC}"
    else
      echo -e "${YELLOW}âš  Formatting issues${NC}"
      echo -e "  ${CYAN}â†’ Run: black .${NC}"
    fi
  fi
  
  if [[ " ${project_env[@]} " =~ " ruff " ]] && command -v ruff >/dev/null 2>&1; then
    echo -n "  Ruff linting: "
    if ruff check . >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“${NC}"
    else
      echo -e "${YELLOW}âš  Linting issues${NC}"
      echo -e "  ${CYAN}â†’ Run: ruff check --fix .${NC}"
    fi
  fi
  
  # JavaScript/TypeScript linting
  if [[ " ${project_env[@]} " =~ " eslint " ]] && [ -f "package.json" ]; then
    echo -n "  ESLint: "
    if npm run lint >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“${NC}"
    else
      echo -e "${YELLOW}âš  Linting issues${NC}"
      echo -e "  ${CYAN}â†’ Run: npm run lint --fix${NC}"
    fi
  fi
  
  # Type checking
  if [[ " ${project_env[@]} " =~ " mypy " ]] && command -v mypy >/dev/null 2>&1; then
    echo -n "  Type checking (mypy): "
    if mypy . >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“${NC}"
    else
      echo -e "${YELLOW}âš  Type errors${NC}"
      echo -e "  ${CYAN}â†’ Fix type errors${NC}"
    fi
  fi
  
  # 4. Git Status Checks
  echo -e "\n${BRIGHT_BLURPLE}ðŸ“ Checking git status...${NC}"
  
  echo -n "  Uncommitted changes: "
  if [ -z "$(git status --porcelain 2>/dev/null)" ]; then
    echo -e "${GREEN}âœ“ Working directory clean${NC}"
  else
    echo -e "${YELLOW}âš  Uncommitted changes found${NC}"
    echo -e "  ${CYAN}â†’ Commit your changes${NC}"
  fi
  
  echo -n "  Branch status: "
  local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
  if [ "$ahead" -eq 0 ]; then
    echo -e "${GREEN}âœ“ Up to date with remote${NC}"
  else
    echo -e "${YELLOW}âš  $ahead commits ahead of remote${NC}"
    echo -e "  ${CYAN}â†’ Push your commits${NC}"
  fi
  
  # 5. Build Checks
  echo -e "\n${BRIGHT_BLURPLE}ðŸ”¨ Checking build...${NC}"
  
  if [[ " ${project_env[@]} " =~ " make " ]] && grep -q "^build:" Makefile 2>/dev/null; then
    echo -n "  Make build: "
    if make build >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ Build successful${NC}"
    else
      echo -e "${RED}âœ— Build failed${NC}"
      ((failed_checks++))
    fi
  elif [[ " ${project_env[@]} " =~ " node " ]] && grep -q '"build"' package.json 2>/dev/null; then
    echo -n "  NPM build: "
    if npm run build >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ Build successful${NC}"
    else
      echo -e "${RED}âœ— Build failed${NC}"
      ((failed_checks++))
    fi
  elif [[ " ${project_env[@]} " =~ " python-poetry " ]]; then
    echo -n "  Poetry build: "
    if poetry build >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ Build successful${NC}"
    else
      echo -e "${RED}âœ— Build failed${NC}"
      ((failed_checks++))
    fi
  fi
  
  # 6. Deployment Readiness Assessment
  echo -e "\n${BRIGHT_BLURPLE}ðŸš€ Deployment Readiness Assessment${NC}"
  
  # Check for critical missing capabilities
  local has_tests=0
  local has_dependency_management=0
  
  if [[ " ${project_env[@]} " =~ " pytest " ]] || [[ " ${project_env[@]} " =~ " jest " ]] || \
     [[ " ${project_env[@]} " =~ " tests-dir " ]] || ([ -f "Makefile" ] && grep -q "^test:" Makefile 2>/dev/null); then
    has_tests=1
  fi
  
  if [[ " ${project_env[@]} " =~ " poetry-lock " ]] || [[ " ${project_env[@]} " =~ " npm-lock " ]] || \
     [[ " ${project_env[@]} " =~ " yarn-lock " ]] || [[ " ${project_env[@]} " =~ " pnpm-lock " ]]; then
    has_dependency_management=1
  fi
  
  # Summary with recommendations
  echo -e "\n${BRIGHT_BLURPLE}ðŸ“Š Completion Check Summary${NC}"
  
  if [ $failed_checks -eq 0 ]; then
    echo -e "${GREEN}âœ… All critical checks passed!${NC}"
    
    # Add warnings for missing best practices
    if [ $has_tests -eq 0 ]; then
      echo -e "\n${YELLOW}âš ï¸  Recommendation: Add automated tests${NC}"
      echo -e "${CYAN}   Tests prevent regressions and verify code works${NC}"
    fi
    
    if [ $has_dependency_management -eq 0 ] && ([[ " ${project_env[@]} " =~ " node " ]] || [[ " ${project_env[@]} " =~ " python" ]]); then
      echo -e "\n${YELLOW}âš ï¸  Recommendation: Use dependency lock files${NC}"
      echo -e "${CYAN}   Lock files ensure reproducible builds across environments${NC}"
    fi
    
    return 0
  else
    echo -e "${RED}âŒ $failed_checks critical check(s) failed${NC}"
    echo -e "\n${YELLOW}These failures indicate potential deployment issues.${NC}"
    echo -e "${YELLOW}Fix them or use 'y' to override if you have alternative verification.${NC}"
    return 1
  fi
}

# Function to clean up and optimize AICheck state
function cleanup_and_optimize() {
    echo -e "${BRIGHT_BLURPLE}ðŸ§¹ AICheck Cleanup & Optimization${NC}"
    echo ""
    
    # Run validation to identify issues
    echo -e "${BRIGHT_BLURPLE}Analyzing current state...${NC}"
    validate_action_completeness
    
    # Clean up multiple active actions
    local active_count=$(grep -c "| .* | .* | Active\(Action\)\? | .* | .* |" .aicheck/actions_index.md 2>/dev/null | tr -d '\n')
    active_count=${active_count:-0}
    if [ "$active_count" -gt 1 ]; then
      echo -e "\n${YELLOW}âš  Multiple active actions detected ($active_count)${NC}"
      echo -e "${RED}This violates AICheck's single-action principle!${NC}"
      echo "Active actions:"
      grep -E "\\| .* \\| .* \\| (Active|ActiveAction) \\| .* \\| .* \\|" .aicheck/actions_index.md | awk -F'|' '{print "  - " $2 " (Status: " $4 ")"}'
      
      echo -e "\n${CYAN}Would you like to:${NC}"
      echo -e "  1) Keep only the current action ($(cat .aicheck/current_action 2>/dev/null || echo 'None'))"
      echo -e "  2) Choose a different action"
      echo -e "  3) Mark all as 'Not Started'"
      echo -n "Choice (1-3): "
      read choice
      
      case "$choice" in
        1)
          fix_multiple_active_actions "current"
          ;;
        2)
          echo "Enter action name to keep active: "
          read action_name
          fix_multiple_active_actions "$action_name"
          ;;
        3)
          fix_multiple_active_actions "none"
          ;;
        *)
          echo -e "${YELLOW}Skipping active action cleanup${NC}"
          ;;
      esac
    fi
    
    # Suggest git cleanup
    local uncommitted=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$uncommitted" -gt 0 ]; then
      echo -e "\n${YELLOW}âš  $uncommitted uncommitted changes${NC}"
      echo -e "${CYAN}â†’ Commit or stash changes to reduce context pollution${NC}"
    fi
    
    # Suggest action completion
    local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
    if [ "$current_action" != "None" ]; then
      echo -e "\n${BRIGHT_BLURPLE}Current action: $current_action${NC}"
      echo -e "${CYAN}â†’ Complete with: ./aicheck complete${NC}"
      echo -e "${CYAN}â†’ Or switch with: ./aicheck ACTIVE <other-action>${NC}"
    fi
    
    # Check for orphaned action directories
    echo -e "\n${BRIGHT_BLURPLE}Checking for orphaned actions...${NC}"
    local orphaned_count=0
    for dir in .aicheck/actions/*/; do
      if [ -d "$dir" ]; then
        local action_name=$(basename "$dir")
        # Convert directory name back to PascalCase
        local pascal_name=$(echo "$action_name" | sed 's/-\([a-z]\)/\U\1/g' | sed 's/^./\U&/')
        
        if ! grep -q "| $pascal_name |" .aicheck/actions_index.md 2>/dev/null; then
          ((orphaned_count++))
          echo -e "${YELLOW}  - $action_name (not in index)${NC}"
        fi
      fi
    done
    
    if [ $orphaned_count -gt 0 ]; then
      echo -e "${CYAN}â†’ Found $orphaned_count orphaned action directories${NC}"
      echo -e "${CYAN}â†’ These can be safely removed if no longer needed${NC}"
    else
      echo -e "${GREEN}âœ“ No orphaned actions found${NC}"
    fi
    
    echo -e "\n${GREEN}âœ“ Cleanup analysis complete${NC}"
}

# Function to fix multiple active actions and sync state
function fix_multiple_active_actions() {
  local mode=$1
  
  echo -e "${BLUE}Synchronizing action state...${NC}"
  
  # First, clear ALL active statuses to ensure clean state
  # Update actions_index.md - change all Active/ActiveAction to Not Started
  sed -i "" 's/| \(.*\) | \(.*\) | Active | \(.*\) | \(.*\) |/| \1 | \2 | Not Started | \3 | \4 |/g' .aicheck/actions_index.md
  sed -i "" 's/| \(.*\) | \(.*\) | ActiveAction | \(.*\) | \(.*\) |/| \1 | \2 | Not Started | \3 | \4 |/g' .aicheck/actions_index.md
  
  # Update all status.txt files to remove ActiveAction
  find .aicheck/actions -name "status.txt" -exec grep -l "ActiveAction" {} \; 2>/dev/null | while read status_file; do
    echo "Not Started" > "$status_file"
  done
  
  case "$mode" in
    "current")
      local current=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      if [ "$current" != "None" ] && [ "$current" != "" ]; then
        # Set this action as the ONLY active one
        local dir_name=$(echo "$current" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
        if [ -d ".aicheck/actions/$dir_name" ]; then
          echo "ActiveAction" > ".aicheck/actions/$dir_name/status.txt"
          sed -i "" "s/| $current | \(.*\) | Not Started | \(.*\) | \(.*\) |/| $current | \1 | ActiveAction | \2 | \3 |/" .aicheck/actions_index.md
          echo -e "${GREEN}âœ“ Set $current as the ONLY active action${NC}"
        else
          echo -e "${RED}Current action directory not found, clearing...${NC}"
          fix_multiple_active_actions "none"
        fi
      else
        fix_multiple_active_actions "none"
      fi
      ;;
    "none")
      # Clear current action
      echo "None" > .aicheck/current_action
      echo -e "${GREEN}âœ“ All actions marked as 'Not Started'${NC}"
      echo -e "${GREEN}âœ“ No active action set${NC}"
      ;;
    *)
      # Set specific action as active
      local dir_name=$(echo "$mode" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
      if [ -d ".aicheck/actions/$dir_name" ]; then
        # Update current_action file
        echo "$mode" > .aicheck/current_action
        # Update status file
        echo "ActiveAction" > ".aicheck/actions/$dir_name/status.txt"
        # Update index
        sed -i "" "s/| $mode | \(.*\) | Not Started | \(.*\) | \(.*\) |/| $mode | \1 | ActiveAction | \2 | \3 |/" .aicheck/actions_index.md
        echo -e "${GREEN}âœ“ Set $mode as the ONLY active action${NC}"
      else
        echo -e "${RED}Error: Action '$mode' not found${NC}"
      fi
      ;;
  esac
  
  # Update last modified date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  
  # Final verification
  local index_active=$(grep -c "| .* | .* | ActiveAction | .* | .* |" .aicheck/actions_index.md 2>/dev/null)
  index_active=${index_active:-0}
  local status_active=$(find .aicheck/actions -name "status.txt" -exec grep -l "ActiveAction" {} \; 2>/dev/null | wc -l | tr -d ' ')
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "\n${BRIGHT_BLURPLE}State verification:${NC}"
  echo -e "  Current action file: ${CYAN}$current_action${NC}"
  echo -e "  Active in index: ${CYAN}$index_active${NC}"
  echo -e "  Active status files: ${CYAN}$status_active${NC}"
  
  if [ "$index_active" -gt 1 ] || [ "$status_active" -gt 1 ]; then
    echo -e "${RED}âš  WARNING: Multiple active actions still detected!${NC}"
    echo -e "${YELLOW}Manual intervention may be required${NC}"
  elif [ "$index_active" -eq 0 ] && [ "$current_action" != "None" ]; then
    echo -e "${YELLOW}âš  WARNING: current_action is set but no action is active in index${NC}"
  fi
}

# Function to complete an action
function complete_action() {
  local action_name=$1
  
  # If no action name is provided, use the current action
  if [ -z "$action_name" ]; then
    if [ -f ".aicheck/current_action" ]; then
      action_name=$(cat .aicheck/current_action)
    fi
  fi
  
  if [ -z "$action_name" ] || [ "$action_name" = "None" ] || [ "$action_name" = "AICheckExec" ]; then
    echo -e "${RED}Error: No action specified and no current action set${NC}"
    echo "Usage: ./aicheck action complete [ACTION_NAME]"
    exit 1
  fi
  
  # Convert PascalCase to kebab-case for directories (compatible with macOS)
  local dir_name=$(echo "$action_name" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  # Check if action exists
  if [ ! -d ".aicheck/actions/$dir_name" ]; then
    echo -e "${RED}Error: Action '$action_name' does not exist${NC}"
    echo "Available actions:"
    ls -1 .aicheck/actions/ | grep -v "README"
    exit 1
  fi
  
  # Run smart completion checks
  echo -e "${BRIGHT_BLURPLE}Running completion checks for $action_name...${NC}"
  
  # Run the smart completion checks function
  run_smart_completion_checks "$action_name" "$dir_name"
  
  # Check if completion checks passed
  if [ $? -ne 0 ]; then
    echo -e "${YELLOW}âš ï¸  Some completion checks failed${NC}"
    echo -e "${YELLOW}Continue anyway? (y/n)${NC}"
    read -r continue_anyway
    
    if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
      echo -e "${YELLOW}Action completion aborted. Please fix the issues first.${NC}"
      exit 0
    fi
  fi
  
  # Update action status
  echo "Completed" > ".aicheck/actions/$dir_name/status.txt"
  
  # Update progress to 100%
  sed -i "" "s/Progress: .*%/Progress: 100%/" ".aicheck/actions/$dir_name/$dir_name-plan.md"
  
  # Update actions_index.md
  # First, remove from Active Actions
  sed -i "" "/| $action_name | .* | [^|]* | [^|]* | .*|/d" .aicheck/actions_index.md
  
  # Then, add to Completed Actions
  # Get the line number of the "Completed Actions" table's end
  line_num=$(grep -n "\| \*None yet\* \| \| \| \|" .aicheck/actions_index.md | sed -n '2p' | cut -d':' -f1)
  
  if [ -n "$line_num" ]; then
    # Replace the "None yet" line with the new action
    sed -i "" "$line_num s/| \*None yet\* | | | |/| $action_name | | $(date +"%Y-%m-%d") | |\n| \*None yet\* | | | |/" .aicheck/actions_index.md
  else
    # Append to the Completed Actions table
    line_num=$(grep -n "## Completed Actions" .aicheck/actions_index.md | cut -d':' -f1)
    if [ -n "$line_num" ]; then
      awk -v line="$line_num" -v action="| $action_name | | $(date +"%Y-%m-%d") | |" 'NR==line+4{print action}1' .aicheck/actions_index.md > .aicheck/actions_index.md.tmp
      mv .aicheck/actions_index.md.tmp .aicheck/actions_index.md
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  
  # If this was the current action, set current action to None
  if [ -f ".aicheck/current_action" ] && [ "$(cat .aicheck/current_action)" = "$action_name" ]; then
    echo "None" > .aicheck/current_action
    echo -e "${BRIGHT_BLURPLE}Current action reset to None${NC}"
  fi
  
  echo -e "${GREEN}âœ“ Completed ACTION: $action_name${NC}"
  echo -e "${BRIGHT_BLURPLE}Updated status, progress, and actions index${NC}"
}

# Function to toggle exec mode
function exec_mode() {
  # Save current action
  local current_action=$(cat .aicheck/current_action)
  
  if [ "$current_action" = "AICheckExec" ]; then
    # Exit exec mode, return to previous action
    if [ -f .aicheck/previous_action ]; then
      local previous_action=$(cat .aicheck/previous_action)
      echo "$previous_action" > .aicheck/current_action
      rm .aicheck/previous_action
      echo -e "${GREEN}âœ“ Exited Exec Mode${NC}"
      echo -e "${BRIGHT_BLURPLE}Returned to action: $previous_action${NC}"
    else
      echo "None" > .aicheck/current_action
      echo -e "${GREEN}âœ“ Exited Exec Mode${NC}"
      echo -e "${BRIGHT_BLURPLE}No previous action found${NC}"
    fi
  else
    # Enter exec mode, save current action
    echo "$current_action" > .aicheck/previous_action
    echo "AICheckExec" > .aicheck/current_action
    echo -e "${GREEN}âœ“ Entered AICheck Exec Mode${NC}"
    echo -e "${YELLOW}NOTE: Exec Mode is for system maintenance only${NC}"
    echo -e "${YELLOW}No substantive code changes should be made in this mode${NC}"
  fi
}

# Function to add an external dependency
function add_dependency() {
  local name=$1
  local version=$2
  local justification=$3
  local action=$4
  
  if [ -z "$name" ] || [ -z "$version" ] || [ -z "$justification" ]; then
    echo -e "${RED}Error: Missing required arguments${NC}"
    echo "Usage: ./aicheck dependency add NAME VERSION JUSTIFICATION [ACTION]"
    exit 1
  fi
  
  # If no action is provided, use the current action
  if [ -z "$action" ]; then
    if [ -f ".aicheck/current_action" ]; then
      action=$(cat .aicheck/current_action)
    fi
  fi
  
  if [ -z "$action" ] || [ "$action" = "None" ] || [ "$action" = "AICheckExec" ]; then
    echo -e "${YELLOW}Warning: No action specified or current action set.${NC}"
    echo -e "${YELLOW}Dependency will be added without associating with an action.${NC}"
    action=""
  fi
  
  # Create dependency index if it doesn't exist
  mkdir -p documentation/dependencies
  if [ ! -f "documentation/dependencies/dependency_index.md" ]; then
    cat > documentation/dependencies/dependency_index.md << 'EODOC'
# Dependency Index

This document tracks all dependencies in the PROJECT. All dependencies must be registered here.

## External Dependencies

| Dependency | Version | Added By | Date Added | Justification | Actions Using |
|------------|---------|----------|------------|---------------|---------------|
| *None yet* | | | | | |

## Internal Dependencies

| Dependency Action | Dependent Action | Type | Date Added | Description |
|-------------------|------------------|------|------------|-------------|
| *None yet* | | | | |

---
*Last Updated: $(date +"%Y-%m-%d")*
EODOC
  fi
  
  # Check if dependency already exists
  if grep -q "| $name | $version |" documentation/dependencies/dependency_index.md; then
    echo -e "${YELLOW}Dependency $name@$version already exists.${NC}"
    echo -e "${YELLOW}Updating to add this action as a user.${NC}"
    
    # Extract existing actions using this dependency
    local existing_actions=$(grep "| $name | $version |" documentation/dependencies/dependency_index.md | awk -F '|' '{print $6}' | xargs)
    
    # Add the current action if not already included
    if [ -n "$action" ] && ! echo "$existing_actions" | grep -q "$action"; then
      local new_actions="$existing_actions, $action"
      # Update the dependency entry
      sed -i "" "s/| $name | $version |.*|.*|.*|.*|/| $name | $version | | $(date +"%Y-%m-%d") | $justification | $new_actions |/" documentation/dependencies/dependency_index.md
    fi
  else
    # Get the line number of the "External Dependencies" table's "None yet" row
    line_num=$(grep -n "\| \*None yet\* \| \| \| \| \| \|" documentation/dependencies/dependency_index.md | cut -d':' -f1)
    
    if [ -n "$line_num" ]; then
      # Replace the "None yet" line with the new dependency
      sed -i "" "$line_num s/| \*None yet\* | | | | | |/| $name | $version | | $(date +"%Y-%m-%d") | $justification | $action |\n| \*None yet\* | | | | | |/" documentation/dependencies/dependency_index.md
    else
      # Append to the External Dependencies table
      line_num=$(grep -n "## External Dependencies" documentation/dependencies/dependency_index.md | cut -d':' -f1)
      if [ -n "$line_num" ]; then
        let line_num+=4  # Move to after the header row
        awk -v line="$line_num" -v dep="| $name | $version | | $(date +"%Y-%m-%d") | $justification | $action |" 'NR==line{print dep}1' documentation/dependencies/dependency_index.md > documentation/dependencies/dependency_index.md.tmp
        mv documentation/dependencies/dependency_index.md.tmp documentation/dependencies/dependency_index.md
      fi
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" documentation/dependencies/dependency_index.md
  
  echo -e "${GREEN}âœ“ Added external dependency: $name@$version${NC}"
  if [ -n "$action" ]; then
    echo -e "${BRIGHT_BLURPLE}Associated with action: $action${NC}"
  fi
}

# Function to add an internal dependency
function add_internal_dependency() {
  local dep_action=$1
  local action=$2
  local type=$3
  local description=$4
  
  if [ -z "$dep_action" ] || [ -z "$action" ] || [ -z "$type" ]; then
    echo -e "${RED}Error: Missing required arguments${NC}"
    echo "Usage: ./aicheck dependency internal DEP_ACTION ACTION TYPE [DESCRIPTION]"
    exit 1
  fi
  
  # Create dependency index if it doesn't exist
  mkdir -p documentation/dependencies
  if [ ! -f "documentation/dependencies/dependency_index.md" ]; then
    cat > documentation/dependencies/dependency_index.md << 'EODOC2'
# Dependency Index

This document tracks all dependencies in the PROJECT. All dependencies must be registered here.

## External Dependencies

| Dependency | Version | Added By | Date Added | Justification | Actions Using |
|------------|---------|----------|------------|---------------|---------------|
| *None yet* | | | | | |

## Internal Dependencies

| Dependency Action | Dependent Action | Type | Date Added | Description |
|-------------------|------------------|------|------------|-------------|
| *None yet* | | | | |

---
*Last Updated: $(date +"%Y-%m-%d")*
EODOC2
  fi
  
  # Check if both actions exist
  local dep_dir_name=$(echo "$dep_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir_name=$(echo "$action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  if [ ! -d ".aicheck/actions/$dep_dir_name" ]; then
    echo -e "${YELLOW}Warning: Dependency action '$dep_action' does not exist.${NC}"
  fi
  
  if [ ! -d ".aicheck/actions/$action_dir_name" ]; then
    echo -e "${YELLOW}Warning: Dependent action '$action' does not exist.${NC}"
  fi
  
  # Get the line number of the "Internal Dependencies" table's "None yet" row
  line_num=$(grep -n "\| \*None yet\* \| \| \| \| \|" documentation/dependencies/dependency_index.md | sed -n '2p' | cut -d':' -f1)
  
  if [ -n "$line_num" ]; then
    # Replace the "None yet" line with the new dependency
    sed -i "" "$line_num s/| \*None yet\* | | | | |/| $dep_action | $action | $type | $(date +"%Y-%m-%d") | ${description:-\"\"} |\n| \*None yet\* | | | | |/" documentation/dependencies/dependency_index.md
  else
    # Append to the Internal Dependencies table
    line_num=$(grep -n "## Internal Dependencies" documentation/dependencies/dependency_index.md | cut -d':' -f1)
    if [ -n "$line_num" ]; then
      let line_num+=4  # Move to after the header row
      awk -v line="$line_num" -v dep="| $dep_action | $action | $type | $(date +"%Y-%m-%d") | ${description:-\"\"} |" 'NR==line{print dep}1' documentation/dependencies/dependency_index.md > documentation/dependencies/dependency_index.md.tmp
      mv documentation/dependencies/dependency_index.md.tmp documentation/dependencies/dependency_index.md
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" documentation/dependencies/dependency_index.md
  
  echo -e "${GREEN}âœ“ Added internal dependency${NC}"
  echo -e "${BRIGHT_BLURPLE}$action depends on $dep_action ($type)${NC}"
}

# Function to show the current status
function show_status() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Status${NC}"
  echo -e "-------------------"
  echo -e "Current Action: ${GREEN}$current_action${NC}"
  
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    # Convert PascalCase to kebab-case for directories
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    
    if [ -d ".aicheck/actions/$dir_name" ]; then
      local status=$(cat ".aicheck/actions/$dir_name/status.txt" 2>/dev/null || echo "Unknown")
      local progress=$(grep "Progress:" ".aicheck/actions/$dir_name/$dir_name-plan.md" 2>/dev/null | cut -d':' -f2 | tr -d ' %' || echo "0")
      
      echo -e "Status: ${GREEN}$status${NC}"
      echo -e "Progress: ${GREEN}$progress%${NC}"
      echo -e "Plan: ${BRIGHT_BLURPLE}.aicheck/actions/$dir_name/$dir_name-plan.md${NC}"
      
      # Show dependencies
      if [ -f "documentation/dependencies/dependency_index.md" ]; then
        local deps=$(grep -c "$current_action" documentation/dependencies/dependency_index.md 2>/dev/null)
        deps=${deps:-0}  # Default to 0 if empty
        if [ "$deps" -gt "0" ]; then
          echo -e "\nDependencies for $current_action:"
          grep "$current_action" documentation/dependencies/dependency_index.md
        fi
      fi
    else
      echo -e "${YELLOW}Warning: Action directory not found for $current_action${NC}"
    fi
  elif [ "$current_action" = "AICheckExec" ]; then
    echo -e "${YELLOW}SYSTEM IS IN EXEC MODE${NC}"
    echo -e "${YELLOW}For system maintenance only${NC}"
    if [ -f .aicheck/previous_action ]; then
      local previous_action=$(cat .aicheck/previous_action)
      echo -e "Previous action: ${BRIGHT_BLURPLE}$previous_action${NC} (will be restored on exec mode exit)"
    fi
  fi
  
  # Show active actions
  echo -e "\nActive Actions:"
  if [ -f ".aicheck/actions_index.md" ]; then
    grep -A 5 "## Active Actions" .aicheck/actions_index.md | tail -n +4 | grep -v "\*None yet\*" | grep -v "^$" || echo "No active actions"
  else
    echo "No action index found"
  fi
  
  # Show context pollution analysis
  echo -e "\nContext Health:"
  pollution_data=$(detect_context_pollution)
  pollution_score=$(echo "$pollution_data" | head -1)
  warnings=$(echo "$pollution_data" | tail -n +2)
  
  if [ "$pollution_score" -le 20 ]; then
    echo -e "Pollution score: ${GREEN}$pollution_score/100 (Clean)${NC}"
  elif [ "$pollution_score" -le 50 ]; then
    echo -e "Pollution score: ${YELLOW}$pollution_score/100 (Moderate)${NC}"
  else
    echo -e "Pollution score: ${RED}$pollution_score/100 (High)${NC}"
    echo -e "${YELLOW}Consider running './aicheck context clear'${NC}"
  fi
  
  if [ -n "$warnings" ] && [ "$warnings" != "WARNINGS:" ]; then
    echo -e "${YELLOW}$warnings${NC}"
  fi
  
  # Show git status if in a git repo
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo -e "\nGit Status:"
    echo -e "Branch: $(git branch --show-current 2>/dev/null)"
    echo -e "Changes: $(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
    echo -e "Last commit: $(git log -1 --oneline 2>/dev/null || echo "No commits yet")"
  fi
  
  # Automatically check boundaries if there's an active action
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    echo -e "\nBoundary Check:"
    if enforce_action_boundaries >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ Action boundaries maintained${NC}"
    else
      echo -e "${YELLOW}âš  Potential scope creep detected - run './aicheck context check' for details${NC}"
    fi
  fi
}

# Guardian System Functions
function handle_guardian() {
  local GUARDIAN_DIR=".aicheck/guardian"
  local GUARDIAN_DB="$GUARDIAN_DIR/guardian.db"
  local GUARDIAN_LOG="$GUARDIAN_DIR/guardian.log"
  local PROTECTED_FILES="$GUARDIAN_DIR/protected_files.txt"
  local HASHES_DB="$GUARDIAN_DIR/file_hashes.db"
  
  local subcmd="$1"
  shift
  
  case "$subcmd" in
    "init")
      mkdir -p "$GUARDIAN_DIR"
      touch "$GUARDIAN_DB" "$GUARDIAN_LOG" "$PROTECTED_FILES" "$HASHES_DB"
      echo -e "${BLUE}ðŸ›¡ï¸  AICheck Guardian Initialized${NC}"
      echo -e "${YELLOW}Use './aicheck guardian protect <file> <CRITICAL|SENSITIVE|MONITORED>' to protect files${NC}"
      ;;
    "protect")
      local file="$1"
      local level="${2:-MONITORED}"
      if [ ! -f "$file" ]; then
        echo -e "${RED}âœ— File not found: $file${NC}"
        return 1
      fi
      local hash=$(shasum -a 256 "$file" | cut -d' ' -f1)
      echo "$file|$level|$hash|$(date +%s)" >> "$PROTECTED_FILES"
      echo "$file:$hash:$(date +%s)" >> "$HASHES_DB"
      echo "[$(date '+%Y-%m-%d %H:%M:%S')] PROTECT | $file | Added to $level protection | User: $(whoami)" >> "$GUARDIAN_LOG"
      echo -e "${GREEN}âœ“ Protected: $file (Level: $level)${NC}"
      ;;
    "check"|"scan")
      echo -e "${BLUE}ðŸ” Scanning protected files...${NC}"
      local violations=0
      while IFS='|' read -r file level hash timestamp; do
        if [ -n "$file" ] && [ -f "$file" ]; then
          local stored_hash=$(grep "^$file:" "$HASHES_DB" 2>/dev/null | cut -d':' -f2 | tail -1)
          local current_hash=$(shasum -a 256 "$file" 2>/dev/null | cut -d' ' -f1)
          if [ "$stored_hash" != "$current_hash" ]; then
            echo -e "${RED}ðŸš¨ INTEGRITY VIOLATION: $file has been modified!${NC}"
            if [ "$level" = "CRITICAL" ]; then
              echo -e "${RED}CRITICAL FILE MODIFIED - IMMEDIATE ACTION REQUIRED${NC}"
            fi
            ((violations++))
          else
            echo -e "${GREEN}âœ“ Integrity verified: $file${NC}"
          fi
        fi
      done < "$PROTECTED_FILES"
      if [ $violations -eq 0 ]; then
        echo -e "${GREEN}âœ… All protected files intact${NC}"
      else
        echo -e "${RED}âš ï¸  Found $violations integrity violations${NC}"
      fi
      ;;
    "status")
      echo -e "${PURPLE}ðŸ›¡ï¸  AICheck Guardian Status${NC}"
      echo "========================="
      if [ -f "$PROTECTED_FILES" ]; then
        local total=$(wc -l < "$PROTECTED_FILES")
        local critical=$(grep "|CRITICAL|" "$PROTECTED_FILES" 2>/dev/null | wc -l)
        local sensitive=$(grep "|SENSITIVE|" "$PROTECTED_FILES" 2>/dev/null | wc -l)
        echo -e "Protected Files: ${BLUE}$total${NC}"
        echo -e "  ${RED}CRITICAL: $critical${NC}"
        echo -e "  ${YELLOW}SENSITIVE: $sensitive${NC}"
      else
        echo -e "${YELLOW}No files protected yet${NC}"
      fi
      
      # Check for blueprints
      if [ -f "$GUARDIAN_DIR/blueprints.json" ]; then
        local blueprint_count=$(grep -c "entry_point" "$GUARDIAN_DIR/blueprints.json" 2>/dev/null)
        blueprint_count=${blueprint_count:-0}
        echo -e "\nCritical Paths: ${BLUE}$blueprint_count${NC}"
      fi
      
      # Integration with AICheck
      local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      if [ "$current_action" != "None" ]; then
        echo -e "\nActive Action: ${GREEN}$current_action${NC}"
        echo -e "Guardian Mode: ${YELLOW}Monitoring changes${NC}"
      fi
      ;;
    
    "blueprint")
      local action="$1"
      shift
      case "$action" in
        "add")
          # Add a critical path blueprint
          local name="$1"
          local entry="$2"
          echo -e "${BLUE}Adding critical path: $name${NC}"
          mkdir -p "$GUARDIAN_DIR"
          # Store blueprint (simplified for bash)
          echo "$name|$entry|$(date +%s)" >> "$GUARDIAN_DIR/blueprints.txt"
          echo -e "${GREEN}âœ“ Blueprint added. Define flow with 'blueprint flow $name file1 file2...'${NC}"
          ;;
        "analyze")
          # Analyze proposed change
          local file="$1"
          echo -e "${BLUE}ðŸ” Analyzing proposed change to: $file${NC}"
          
          # Check if file is in any critical path
          local in_critical_path=false
          local affected_paths=""
          
          if [ -f "$GUARDIAN_DIR/blueprints.txt" ]; then
            while IFS='|' read -r path_name entry_point timestamp; do
              # Simple check - in real implementation would parse flow
              if [[ "$file" == *"$entry_point"* ]]; then
                in_critical_path=true
                affected_paths="$affected_paths $path_name"
              fi
            done < "$GUARDIAN_DIR/blueprints.txt"
          fi
          
          if [ "$in_critical_path" = true ]; then
            echo -e "${YELLOW}âš ï¸  File is part of critical paths:$affected_paths${NC}"
            
            # Check with dependency system
            echo -e "\n${BLUE}Checking dependencies...${NC}"
            local deps=$(grep -l "$file" documentation/dependencies/dependency_index.md 2>/dev/null)
            if [ -n "$deps" ]; then
              echo -e "${YELLOW}This file is referenced in dependency index${NC}"
            fi
            
            # Check current action context
            if [ "$current_action" != "None" ] && [ -f ".aicheck/actions/${current_action,,}/$(echo $current_action | tr '[:upper:]' '[:lower:]')-plan.md" ]; then
              echo -e "\n${BLUE}Checking action plan...${NC}"
              local in_plan=$(grep -c "$file" ".aicheck/actions/${current_action,,}/$(echo $current_action | tr '[:upper:]' '[:lower:]')-plan.md" 2>/dev/null)
              in_plan=${in_plan:-0}
              if [ "$in_plan" -gt 0 ]; then
                echo -e "${GREEN}âœ“ File modification is part of current action plan${NC}"
              else
                echo -e "${RED}âŒ File not mentioned in current action plan${NC}"
                echo -e "${YELLOW}Consider updating action plan before proceeding${NC}"
              fi
            fi
            
            echo -e "\n${PURPLE}Change Impact Analysis:${NC}"
            echo -e "1. Run tests for affected paths"
            echo -e "2. Update documentation if contracts change"
            echo -e "3. Notify dependent modules"
            echo -e "4. Consider backward compatibility"
          else
            echo -e "${GREEN}âœ“ File is not in critical paths${NC}"
          fi
          ;;
        *)
          echo "Usage: ./aicheck guardian blueprint {add|analyze}"
          ;;
      esac
      ;;
    "analyze")
      # Deep analysis of proposed changes
      local file="$1"
      if [ -z "$file" ]; then
        echo -e "${RED}Please specify a file to analyze${NC}"
        return 1
      fi
      
      echo -e "${BLUE}ðŸ”¬ Deep Analysis of: $file${NC}"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      # Run conflict analyzer
      if [ -f ".aicheck/guardian/conflict_analyzer.sh" ]; then
        .aicheck/guardian/conflict_analyzer.sh "$file"
      fi
      
      # Check protection level
      local protection_level=$(grep "^$file|" "$PROTECTED_FILES" 2>/dev/null | cut -d'|' -f2)
      if [ -n "$protection_level" ]; then
        echo ""
        echo -e "${YELLOW}Protection Level: $protection_level${NC}"
        if [ "$protection_level" = "CRITICAL" ]; then
          echo -e "${RED}âš ï¸  This is a CRITICAL file - changes require approval${NC}"
        fi
      fi
      
      # Integration with AICheck validation
      echo ""
      echo -e "${BLUE}=== AICheck Validation ===${NC}"
      
      # Check if this fits current action
      local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      if [ "$current_action" != "None" ]; then
        # Use AICheck's boundary checking
        local boundary_check=$(enforce_action_boundaries 2>&1 | grep -c "outside.*action")
        boundary_check=${boundary_check:-0}
        if [ "$boundary_check" -gt 0 ]; then
          echo -e "${RED}âŒ Change may be outside current action boundaries${NC}"
        else
          echo -e "${GREEN}âœ“ Change appears within action boundaries${NC}"
        fi
      fi
      
      # Suggest next steps
      echo ""
      echo -e "${PURPLE}Recommended Actions:${NC}"
      echo "1. Review the analysis above"
      echo "2. Run tests: ./aicheck guardian test $file"
      echo "3. Update docs if needed: ./aicheck guardian doc $file"
      echo "4. If approved, update hash: ./aicheck guardian update $file"
      ;;
      
    *)
      echo -e "${BLUE}AICheck Guardian - Code Protection System${NC}"
      echo "Usage: ./aicheck guardian {init|protect|check|scan|status|blueprint|analyze}"
      echo ""
      echo "Commands:"
      echo "  init              Initialize guardian system"
      echo "  protect FILE LVL  Add file to protection (LVL: CRITICAL/SENSITIVE/MONITORED)"
      echo "  check/scan        Check file integrity"
      echo "  status            Show guardian status"
      echo "  blueprint         Manage critical path blueprints"
      echo "  analyze FILE      Deep analysis of proposed changes"
      ;;
  esac
}

# Function to define goals for auto-iterate session
function define_auto_iterate_goals() {
  local goals_file=".aicheck/auto-iterate-goals.md"
  
  echo -e "${BRIGHT_BLURPLE}ðŸŽ¯ Auto-Iterate Goal Definition${NC}"
  echo -e "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e ""
  echo -e "${YELLOW}The AI editor must propose specific, measurable goals for this iteration session.${NC}"
  echo -e "${YELLOW}Goals will be subject to human approval before proceeding.${NC}"
  echo -e ""
  
  # Analyze current test failures to inform goal proposal
  echo -e "${BLUE}ðŸ” Analyzing current test state...${NC}"
  local test_output=""
  local test_result=1
  
  if [ -f "pyproject.toml" ] && command -v poetry >/dev/null 2>&1; then
    echo -e "${BLUE}Running Poetry tests...${NC}"
    test_output=$(poetry run pytest -v 2>&1)
    test_result=$?
  elif [ -f "package.json" ]; then
    echo -e "${BLUE}Running npm tests...${NC}"
    test_output=$(npm test 2>&1)
    test_result=$?
    echo -e "${BLUE}Test completed with exit code: $test_result${NC}"
  else
    echo -e "${RED}No test configuration found. Cannot proceed without tests.${NC}"
    return 1
  fi
  
  if [ $test_result -eq 0 ]; then
    echo -e "${GREEN}âœ… All tests currently pass. No iteration needed.${NC}"
    return 0
  fi
  
  # Extract failure information for goal formation
  local failed_tests=$(echo "$test_output" | grep "FAILED" | wc -l | tr -d ' ')
  local error_types=$(echo "$test_output" | grep -E "(ERROR|FAILED)" | head -5)
  local key_errors=$(echo "$test_output" | grep -E "(ImportError|ModuleNotFoundError|SyntaxError|AssertionError)" | head -3)
  
  echo -e "${RED}Current Test State:${NC}"
  echo -e "  Failed tests: ${RED}$failed_tests${NC}"
  echo -e "  Key issues:"
  echo "$error_types" | while read line; do
    [ -n "$line" ] && echo -e "    ${RED}â€¢ $line${NC}"
  done
  echo ""
  
  # AI Editor Goal Proposal Template
  echo -e "${PURPLE}ðŸ¤– AI EDITOR: Please propose specific goals for this auto-iterate session${NC}"
  echo -e "${PURPLE}Required format:${NC}"
  echo -e ""
  echo -e "GOAL 1: [Specific, measurable objective]"
  echo -e "  - Success criteria: [How to verify completion]"
  echo -e "  - Approach: [High-level strategy]"
  echo -e ""
  echo -e "GOAL 2: [Another specific objective]"
  echo -e "  - Success criteria: [How to verify completion]"
  echo -e "  - Approach: [High-level strategy]"
  echo -e ""
  echo -e "${YELLOW}Example goals:${NC}"
  echo -e "  â€¢ Fix all ImportError issues by updating dependencies"
  echo -e "  â€¢ Resolve syntax errors in test files"
  echo -e "  â€¢ Make failing assertion tests pass by correcting logic"
  echo -e "  â€¢ Achieve 100% test pass rate"
  echo -e ""
  
  # Get current active action to add template to action directory
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    # Add auto-iterate template to the active action's directory
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    local action_dir=".aicheck/actions/$dir_name"
    local template_file="$action_dir/auto-iterate-session-plan.md"
    
    if [ -d "$action_dir" ]; then
      echo -e "${BLUE}Adding auto-iterate session template to active action: ${GREEN}$current_action${NC}"
      
      # Copy the auto-iterate action template to the action directory
      if [ -f "templates/claude/auto-iterate-action.md" ]; then
        cp "templates/claude/auto-iterate-action.md" "$template_file"
        
        # Customize template with current action details
        sed -i.backup \
          -e "s/\[ACTION-NAME\]/$current_action/g" \
          -e "s/\[DATE\]/$(date +"%Y-%m-%d")/g" \
          "$template_file"
        rm -f "$template_file.backup"
        
        echo -e "${GREEN}ðŸ“ Auto-iterate template added: ${BLUE}$template_file${NC}"
      else
        echo -e "${YELLOW}âš ï¸  Auto-iterate template not found. Creating basic template...${NC}"
        
        cat > "$template_file" << EOF
# Auto-Iterate Session for $current_action

**Action:** $current_action  
**Session Date:** $(date +"%Y-%m-%d %H:%M:%S")  
**Type:** Auto-Iterate Session

## Goals for This Session
<!-- AI editor will define specific goals during auto-iterate process -->

## Session Progress
<!-- Track multiple auto-iterate sessions within this action -->

## Integration with Action Plan
<!-- How this auto-iterate session supports the main action objectives -->

EOF
        echo -e "${GREEN}ðŸ“ Basic auto-iterate template created: ${BLUE}$template_file${NC}"
      fi
    else
      echo -e "${YELLOW}âš ï¸  Active action directory not found. Auto-iterate will work but no template added.${NC}"
    fi
  else
    echo -e "${YELLOW}âš ï¸  No active action. Auto-iterate will work independently.${NC}"
    echo -e "${BLUE}ðŸ’¡ Consider running './aicheck new ActionName' first to create an action context.${NC}"
  fi
  
  # Create template goals file for AI editor to fill
  cat > "$goals_file" << 'EOF'
# Auto-Iterate Session Goals
**Session Date:** $(date +"%Y-%m-%d %H:%M:%S")
**Current Action:** $(cat .aicheck/current_action 2>/dev/null || echo "None")

## Test Analysis
**Failed Tests:** $failed_tests
**Key Issues Identified:**
$error_types

## Proposed Goals
<!-- AI EDITOR: Fill in specific, measurable goals below -->

### GOAL 1: [Replace with specific objective]
- **Success Criteria:** [How to verify this goal is complete]
- **Approach:** [High-level strategy to achieve this goal]
- **Risk Assessment:** [What could go wrong]

### GOAL 2: [Replace with another specific objective]
- **Success Criteria:** [How to verify this goal is complete]
- **Approach:** [High-level strategy to achieve this goal]
- **Risk Assessment:** [What could go wrong]

## Constraints
- Maximum iterations: TBD
- Time limit: TBD
- No changes should be committed without human approval
- All changes must be reversible

## Success Definition
<!-- Overall session success is defined as: -->
[ ] All proposed goals completed
[ ] Test pass rate improved to X%
[ ] No regressions introduced
[ ] Code quality maintained

EOF
  
  # Substitute variables in the template (create new file to avoid sed issues)
  local temp_file=$(mktemp)
  sed \
    -e "s/\$failed_tests/$failed_tests/g" \
    -e "s|\$error_types|$error_types|g" \
    "$goals_file" > "$temp_file"
  mv "$temp_file" "$goals_file"
  
  echo -e "${GREEN}ðŸ“ Goals template created: ${BLUE}$goals_file${NC}"
  echo -e ""
  echo -e "${BRIGHT_BLURPLE}NEXT STEPS:${NC}"
  echo -e "1. ${YELLOW}AI Editor: Edit the goals file with specific, measurable objectives${NC}"
  echo -e "2. ${YELLOW}Human: Review and approve goals before proceeding${NC}"
  echo -e "3. ${YELLOW}Run: ./aicheck auto-iterate --execute to begin approved iteration${NC}"
  echo -e ""
  
  return 2  # Special return code indicating goals need to be defined
}

# Function to approve goals before iteration
function approve_auto_iterate_goals() {
  local goals_file=".aicheck/auto-iterate-goals.md"
  
  if [ ! -f "$goals_file" ]; then
    echo -e "${RED}No goals file found. Run './aicheck auto-iterate' first to define goals.${NC}"
    return 1
  fi
  
  echo -e "${BRIGHT_BLURPLE}ðŸŽ¯ Goal Approval Required${NC}"
  echo -e "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e ""
  echo -e "${BLUE}Current goals:${NC}"
  cat "$goals_file"
  echo -e ""
  echo -e "${YELLOW}Do you approve these goals for auto-iteration? ${NC}"
  echo -e "${GREEN}Options:${NC}"
  echo -e "  ${GREEN}y/yes${NC} - Approve and proceed with iteration"
  echo -e "  ${GREEN}e/edit${NC} - Edit goals file"
  echo -e "  ${GREEN}n/no${NC} - Cancel auto-iterate session"
  echo -e ""
  
  read -p "Your choice: " approval
  
  case "$approval" in
    "y"|"yes"|"Y"|"YES")
      echo -e "${GREEN}âœ… Goals approved. Proceeding with auto-iteration...${NC}"
      return 0
      ;;
    "e"|"edit"|"E"|"EDIT")
      echo -e "${BLUE}Opening goals file for editing...${NC}"
      ${EDITOR:-nano} "$goals_file"
      echo -e "${YELLOW}Please run approval again after editing.${NC}"
      return 1
      ;;
    *)
      echo -e "${YELLOW}Auto-iterate session cancelled.${NC}"
      return 1
      ;;
  esac
}

# Function to run automated test-iterate-test cycles
function auto_iterate() {
  # Configuration defaults (can be overridden by config file)
  local default_max_iterations=10
  local default_timeout=300
  local default_auto_continue=true
  local default_human_timeout=30
  local default_test_timeout=120
  local default_enable_recovery=true
  
  # Check for config file
  if [ -f ".aicheck/auto-iterate.conf" ]; then
    source .aicheck/auto-iterate.conf
  fi
  
  # Parse arguments for goal definition vs execution
  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo -e "${BRIGHT_BLURPLE}Auto-Iterate Mode - Goal-Driven Test-Fix-Test Cycles${NC}"
    echo -e ""
    echo -e "${GREEN}Usage:${NC}"
    echo -e "  ./aicheck auto-iterate                    # Define goals (first step)"
    echo -e "  ./aicheck auto-iterate --approve          # Approve defined goals"
    echo -e "  ./aicheck auto-iterate --execute [args]   # Execute approved iteration"
    echo -e ""
    echo -e "${GREEN}Execution Options:${NC}"
    echo -e "  --execute [max_iterations] [timeout]     # Run with approved goals"
    echo -e ""
    echo -e "${GREEN}Examples:${NC}"
    echo -e "  ./aicheck auto-iterate                    # Step 1: Define goals"
    echo -e "  ./aicheck auto-iterate --approve          # Step 2: Human approval"
    echo -e "  ./aicheck auto-iterate --execute          # Step 3: Execute (defaults: $default_max_iterations iterations, ${default_timeout}s)"
    echo -e "  ./aicheck auto-iterate --execute 5        # Execute with max 5 iterations"
    echo -e ""
    echo -e "${YELLOW}Workflow:${NC}"
    echo -e "  1. AI editor analyzes failures and proposes goals"
    echo -e "  2. Human reviews and approves goals"
    echo -e "  3. System iterates toward approved goals"
    echo -e "  4. Human approves any changes before git commit"
    echo -e ""
    echo -e "${GREEN}Config file:${NC} .aicheck/auto-iterate.conf"
    echo -e "  default_max_iterations=$default_max_iterations"
    echo -e "  default_timeout=$default_timeout"
    return 0
  fi
  
  # Handle different phases
  if [[ "$1" == "--approve" ]]; then
    approve_auto_iterate_goals
    return $?
  elif [[ "$1" == "--execute" ]]; then
    shift  # Remove --execute from args
    execute_auto_iterate "$@"
    return $?
  elif [[ "$1" == "--summary" ]]; then
    # Find most recent session and generate summary
    local recent_session=$(ls .aicheck/auto-iterate-session-*.log 2>/dev/null | sort | tail -1)
    if [ -n "$recent_session" ]; then
      local session_id=$(basename "$recent_session" | sed 's/auto-iterate-session-\(.*\)\.log/\1/')
      echo -e "${BLUE}Generating summary for session: $session_id${NC}"
      generate_iteration_summary_and_git_approval "$session_id" "manual" "manual" ".aicheck/auto-iterate-changes-$session_id.md" "$recent_session"
    else
      echo -e "${RED}No auto-iterate sessions found${NC}"
      return 1
    fi
    return $?
  elif [[ "$1" == "--recover" ]]; then
    local session_id="$2"
    echo -e "${BLUE}Recovering auto-iterate session: $session_id${NC}"
    echo -e "${YELLOW}Recovery functionality will resume session state${NC}"
    echo -e "${RED}Recovery implementation needed in future version${NC}"
    return 1
  elif [[ "$1" == "--clean-recovery" ]]; then
    echo -e "${YELLOW}Cleaning up recovery files...${NC}"
    rm -f .aicheck/auto-iterate-state-*.tmp
    echo -e "${GREEN}âœ… Recovery files cleaned${NC}"
    return 0
  else
    # Check for interrupted sessions before starting new one
    if check_auto_iterate_recovery; then
      local proceed=$(get_human_input "Proceed with new session anyway? (y/n):" 30 "n")
      if [[ ! "$proceed" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Use recovery options above or --clean-recovery to clear${NC}"
        return 1
      fi
    fi
    
    # Default: Goal definition phase
    define_auto_iterate_goals
    return $?
  fi
}

# Function to set up signal handlers for auto-iterate recovery
function setup_auto_iterate_signal_handlers() {
  local session_id="$1"
  local log_file="$2"
  local state_file="$3"
  
  # Create state file for recovery
  cat > "$state_file" << EOF
SESSION_ID=$session_id
LOG_FILE=$log_file
INTERRUPTED_AT=$(date +%s)
RECOVERY_AVAILABLE=true
EOF
  
  # Set up signal handlers
  trap "auto_iterate_graceful_shutdown $session_id $log_file $state_file" SIGINT SIGTERM SIGHUP
}

# Function to handle graceful shutdown of auto-iterate
function auto_iterate_graceful_shutdown() {
  local session_id="$1"
  local log_file="$2"
  local state_file="$3"
  
  echo "" >&2
  echo -e "${YELLOW}âš ï¸  Auto-iterate session interrupted${NC}" >&2
  echo "INTERRUPTED: Session $session_id stopped at $(date)" >> "$log_file"
  
  # Update state file
  echo "INTERRUPTED_AT=$(date +%s)" >> "$state_file"
  echo "RECOVERY_NEEDED=true" >> "$state_file"
  
  echo -e "${BLUE}Recovery information saved to: $state_file${NC}" >&2
  echo -e "${YELLOW}To resume: ./aicheck auto-iterate --recover $session_id${NC}" >&2
  echo -e "${YELLOW}To summarize: ./aicheck auto-iterate --summary${NC}" >&2
  
  exit 130  # Standard exit code for SIGINT
}

# Function to check for and handle recovery scenarios
function check_auto_iterate_recovery() {
  local recovery_files=$(ls .aicheck/auto-iterate-state-*.tmp 2>/dev/null | wc -l | tr -d ' ')
  
  if [ "$recovery_files" -gt 0 ]; then
    echo -e "${YELLOW}âš ï¸  Found $recovery_files interrupted auto-iterate session(s)${NC}"
    echo -e "${BLUE}Available recovery options:${NC}"
    
    for state_file in .aicheck/auto-iterate-state-*.tmp; do
      if [ -f "$state_file" ]; then
        source "$state_file"
        echo -e "  ${GREEN}./aicheck auto-iterate --recover $SESSION_ID${NC} - Resume session"
      fi
    done
    
    echo -e "  ${GREEN}./aicheck auto-iterate --clean-recovery${NC} - Clear all recovery files"
    echo ""
    return 0
  fi
  return 1
}

# Function to handle timeout-aware test execution
function run_tests_with_timeout() {
  local test_timeout=${1:-$default_test_timeout}
  local test_output=""
  local test_result=1
  
  echo -e "${BLUE}Running tests with ${test_timeout}s timeout...${NC}"
  
  if [ -f "pyproject.toml" ] && command -v poetry >/dev/null 2>&1; then
    # Use timeout command for Poetry tests
    if command -v timeout >/dev/null 2>&1; then
      test_output=$(timeout ${test_timeout}s poetry run pytest -v 2>&1)
      test_result=$?
      if [ $test_result -eq 124 ]; then
        test_output="$test_output\nTIMEOUT: Tests exceeded ${test_timeout}s limit"
        echo -e "${RED}â° Tests timed out after ${test_timeout}s${NC}"
      fi
    else
      test_output=$(poetry run pytest -v 2>&1)
      test_result=$?
    fi
  elif [ -f "package.json" ]; then
    # Use timeout command for npm tests
    if command -v timeout >/dev/null 2>&1; then
      test_output=$(timeout ${test_timeout}s npm test 2>&1)
      test_result=$?
      if [ $test_result -eq 124 ]; then
        test_output="$test_output\nTIMEOUT: Tests exceeded ${test_timeout}s limit"
        echo -e "${RED}â° Tests timed out after ${test_timeout}s${NC}"
      fi
    else
      test_output=$(npm test 2>&1)
      test_result=$?
    fi
  else
    test_output="No test configuration found"
    test_result=1
  fi
  
  # Return results via global variables (bash limitation workaround)
  echo "$test_result|$test_output"
}

# Function to handle human input with appropriate timeouts
function get_human_input() {
  local prompt="$1"
  local timeout_seconds=${2:-$default_human_timeout}
  local default_value="$3"
  
  echo -e "${YELLOW}$prompt${NC}"
  
  if [ -n "$default_value" ]; then
    echo -e "${BLUE}(Default: $default_value, timeout: ${timeout_seconds}s)${NC}"
  else
    echo -e "${BLUE}(Timeout: ${timeout_seconds}s)${NC}"
  fi
  
  local user_input=""
  if read -t "$timeout_seconds" -p "> " user_input; then
    if [ -z "$user_input" ] && [ -n "$default_value" ]; then
      echo "$default_value"
    else
      echo "$user_input"
    fi
  else
    echo -e "\n${YELLOW}â° Input timeout after ${timeout_seconds}s${NC}" >&2
    if [ -n "$default_value" ]; then
      echo -e "${BLUE}Using default: $default_value${NC}" >&2
      echo "$default_value"
    else
      echo "TIMEOUT"
    fi
  fi
}

# Function to execute the iteration with approved goals
function execute_auto_iterate() {
  local goals_file=".aicheck/auto-iterate-goals.md"
  
  # Check for approved goals
  if [ ! -f "$goals_file" ]; then
    echo -e "${RED}No goals file found. Run './aicheck auto-iterate' first to define goals.${NC}"
    return 1
  fi
  
  local max_iterations=${1:-$default_max_iterations}
  local timeout=${2:-$default_timeout}
  
  # Validate inputs
  if ! [[ "$max_iterations" =~ ^[0-9]+$ ]] || [ "$max_iterations" -eq 0 ]; then
    echo -e "${RED}Error: max_iterations must be a positive integer${NC}"
    return 1
  fi
  
  if ! [[ "$timeout" =~ ^[0-9]+$ ]] || [ "$timeout" -eq 0 ]; then
    echo -e "${RED}Error: timeout must be a positive integer (seconds)${NC}"
    return 1
  fi
  
  # Initialize iteration tracking
  local iteration=1
  local start_time=$(date +%s)
  local session_id=$(date +%Y%m%d_%H%M%S)
  local log_file=".aicheck/auto-iterate-session-$session_id.log"
  local changes_file=".aicheck/auto-iterate-changes-$session_id.md"
  local state_file=".aicheck/auto-iterate-state-$session_id.tmp"
  local git_initial_state=$(git rev-parse HEAD 2>/dev/null || echo "NO_GIT")
  
  # Set up signal handlers for graceful shutdown
  if [ "$default_enable_recovery" = true ]; then
    setup_auto_iterate_signal_handlers "$session_id" "$log_file" "$state_file"
  fi
  
  # Create detailed session log
  mkdir -p .aicheck
  echo "# Auto-Iterate Session Log" > "$log_file"
  echo "Session ID: $session_id" >> "$log_file"
  echo "Start Time: $(date)" >> "$log_file"
  echo "Goals File: $goals_file" >> "$log_file"
  echo "Initial Git State: $git_initial_state" >> "$log_file"
  echo "Max Iterations: $max_iterations" >> "$log_file"
  echo "Timeout: $timeout seconds" >> "$log_file"
  echo "" >> "$log_file"
  
  # Initialize changes tracking
  echo "# Auto-Iterate Changes Summary" > "$changes_file"
  echo "**Session:** $session_id" >> "$changes_file"
  echo "**Start Time:** $(date)" >> "$changes_file"
  echo "" >> "$changes_file"
  echo "## Goals" >> "$changes_file"
  echo '```' >> "$changes_file"
  cat "$goals_file" >> "$changes_file"
  echo '```' >> "$changes_file"
  echo "" >> "$changes_file"
  echo "## Changes Made" >> "$changes_file"
  
  echo -e "${BRIGHT_BLURPLE}ðŸš€ Starting Goal-Driven Auto-Iterate Execution${NC}"
  echo -e "Session ID: ${BLUE}$session_id${NC}"
  echo -e "Max iterations: ${GREEN}$max_iterations${NC}"
  echo -e "Timeout: ${GREEN}$timeout${NC}s"
  echo -e "Goals: ${BLUE}$goals_file${NC}"
  echo -e ""
  
  # Main iteration loop
  while [ $iteration -le $max_iterations ]; do
    local current_time=$(date +%s)
    local elapsed=$((current_time - start_time))
    
    # Check timeout
    if [ $elapsed -gt $timeout ]; then
      echo -e "${YELLOW}â° Timeout reached after ${elapsed}s${NC}"
      echo "TIMEOUT: Session exceeded $timeout seconds" >> "$log_file"
      break
    fi
    
    echo -e "${BRIGHT_BLURPLE}Iteration $iteration/$max_iterations${NC} (${elapsed}s elapsed)"
    echo "=== Iteration $iteration - $(date) ===" >> "$log_file"
    
    # Step 1: Run tests with timeout and check against goals
    echo -e "${YELLOW}ðŸ§ª Running tests...${NC}"
    
    # Use timeout-aware test execution
    local test_results=$(run_tests_with_timeout $default_test_timeout)
    local test_result=$(echo "$test_results" | cut -d'|' -f1)
    local test_output=$(echo "$test_results" | cut -d'|' -f2-)
    
    # Handle test timeout specifically
    if [ $test_result -eq 124 ]; then
      echo -e "${RED}âŒ Tests timed out after ${default_test_timeout}s${NC}"
      echo "TIMEOUT: Tests exceeded timeout limit" >> "$log_file"
      
      local timeout_action=$(get_human_input "Tests timed out. Options: (r)etry, (i)ncrease timeout, (s)kip, (q)uit:" 60 "retry")
      
      case "$timeout_action" in
        "r"|"retry")
          echo -e "${BLUE}Retrying tests...${NC}"
          continue
          ;;
        "i"|"increase")
          default_test_timeout=$((default_test_timeout * 2))
          echo -e "${BLUE}Increased test timeout to ${default_test_timeout}s${NC}"
          continue
          ;;
        "s"|"skip")
          echo -e "${YELLOW}Skipping this iteration due to test timeout${NC}"
          iteration=$((iteration + 1))
          continue
          ;;
        *)
          echo -e "${YELLOW}Quitting due to test timeout${NC}"
          break
          ;;
      esac
    fi
    
    # Log test results
    echo "Test Exit Code: $test_result" >> "$log_file"
    echo "Test Output:" >> "$log_file"
    echo "$test_output" >> "$log_file"
    echo "" >> "$log_file"
    
    # Check if goals are met
    if [ $test_result -eq 0 ]; then
      echo -e "${GREEN}âœ… All tests pass! Checking if goals are fulfilled...${NC}"
      
      # Here we'd need AI editor to verify goals are met
      echo -e "${PURPLE}ðŸ¤– AI EDITOR: Verify that approved goals have been achieved${NC}"
      echo -e "${YELLOW}Review the goals in: ${BLUE}$goals_file${NC}"
      local goals_satisfied=$(get_human_input "Are all goals satisfied? (y/n):" $default_human_timeout)
      
      if [[ "$goals_satisfied" =~ ^[Yy] ]]; then
        echo -e "${GREEN}ðŸŽ‰ Goals achieved! Auto-iterate complete.${NC}"
        echo "SUCCESS: All goals achieved after $iteration iteration(s)" >> "$log_file"
        break
      else
        echo -e "${YELLOW}Goals not fully met. Continuing iteration...${NC}"
      fi
    fi
    
    # Step 2: Analyze failures and track changes
    echo -e "${RED}âŒ Tests still failing${NC}"
    echo -e "${YELLOW}ðŸ” Analyzing failures against goals...${NC}"
    
    local failed_tests=$(echo "$test_output" | grep "FAILED" | wc -l | tr -d ' ')
    local error_summary=$(echo "$test_output" | grep -E "(FAILED|ERROR|AssertionError|SyntaxError|ImportError)" | head -3)
    
    echo -e "${YELLOW}Failed tests: ${RED}$failed_tests${NC}"
    if [ -n "$error_summary" ]; then
      echo -e "${YELLOW}Key errors:${NC}"
      echo "$error_summary" | while read line; do
        echo -e "  ${RED}â€¢ $line${NC}"
      done
    fi
    
    # Track git changes if any
    local git_changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$git_changes" -gt 0 ]; then
      echo "### Iteration $iteration Changes" >> "$changes_file"
      echo "**Time:** $(date)" >> "$changes_file"
      echo "**Test Result:** $test_result (exit code)" >> "$changes_file"
      echo "**Files Modified:**" >> "$changes_file"
      git status --porcelain >> "$changes_file"
      echo "" >> "$changes_file"
    fi
    
    # Step 3: Allow human intervention or automated fixes
    echo -e "${PURPLE}Options for iteration $iteration:${NC}"
    echo -e "  ${GREEN}c${NC} - Continue to next iteration"
    echo -e "  ${GREEN}i${NC} - Intervene manually (pause iteration)"
    echo -e "  ${GREEN}q${NC} - Quit iteration session"
    echo -e "  ${GREEN}s${NC} - Summary and finish"
    
    local action=$(get_human_input "Action:" 15 "c")
    
    case "$action" in
      "i"|"intervene")
        echo -e "${BLUE}Pausing for manual intervention...${NC}"
        echo "MANUAL_INTERVENTION: User requested pause at iteration $iteration" >> "$log_file"
        echo -e "${YELLOW}Make your changes, then run:${NC}"
        echo -e "  ${GREEN}./aicheck auto-iterate --execute $max_iterations $timeout${NC} (to resume)"
        echo -e "  ${GREEN}./aicheck auto-iterate --summary${NC} (to finish and review)"
        return 2
        ;;
      "q"|"quit")
        echo -e "${YELLOW}Auto-iterate stopped by user${NC}"
        echo "STOPPED: User quit at iteration $iteration" >> "$log_file"
        break
        ;;
      "s"|"summary")
        echo -e "${YELLOW}Proceeding to summary${NC}"
        break
        ;;
      *)
        echo -e "${BLUE}Continuing to next iteration...${NC}"
        ;;
    esac
    
    iteration=$((iteration + 1))
    echo ""
  done
  
  # Generate final summary and request git approval
  generate_iteration_summary_and_git_approval "$session_id" "$iteration" "$start_time" "$changes_file" "$log_file"
}

# Function to generate summary and handle git approval
function generate_iteration_summary_and_git_approval() {
  local session_id="$1"
  local final_iteration="$2"
  local start_time="$3"
  local changes_file="$4"
  local log_file="$5"
  
  local final_time=$(date +%s)
  local total_elapsed=$((final_time - start_time))
  local summary_file=".aicheck/auto-iterate-summary-$session_id.md"
  
  echo -e "${BRIGHT_BLURPLE}ðŸ“‹ Auto-Iterate Session Complete${NC}"
  echo -e "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  
  # Generate comprehensive summary
  cat > "$summary_file" << EOF
# Auto-Iterate Session Summary

**Session ID:** $session_id  
**Total Duration:** ${total_elapsed}s ($(($total_elapsed / 60))m $(($total_elapsed % 60))s)  
**Iterations Completed:** $((final_iteration - 1))  
**End Time:** $(date)

## Session Overview

### Goals Review
EOF
  
  cat .aicheck/auto-iterate-goals.md >> "$summary_file"
  
  cat >> "$summary_file" << EOF

### Changes Made
EOF
  
  if [ -f "$changes_file" ]; then
    cat "$changes_file" >> "$summary_file"
  else
    echo "No changes tracked during this session." >> "$summary_file"
  fi
  
  cat >> "$summary_file" << EOF

### Git Status
**Files Modified:**
\`\`\`
$(git status --porcelain 2>/dev/null || echo "No git repository")
\`\`\`

**Git Diff Summary:**
\`\`\`
$(git diff --stat 2>/dev/null || echo "No changes")
\`\`\`

### Final Test Results
\`\`\`
$(if [ -f "pyproject.toml" ] && command -v poetry >/dev/null 2>&1; then
    poetry run pytest --tb=short 2>&1 | tail -10
  elif [ -f "package.json" ]; then
    npm test 2>&1 | tail -10
  else
    echo "No test configuration"
  fi)
\`\`\`

## Recommendations

### Achieved
- [ ] List what was successfully completed
- [ ] Note any goals that were fully met
- [ ] Document any improvements made

### Still Needed
- [ ] List remaining issues
- [ ] Note any goals not achieved
- [ ] Suggest next steps

### Code Quality
- [ ] No regressions introduced
- [ ] Code follows project standards
- [ ] Tests are comprehensive
- [ ] Documentation updated if needed

EOF
  
  # Display summary
  echo -e "${BLUE}Summary generated: ${BRIGHT_BLURPLE}$summary_file${NC}"
  echo -e ""
  echo -e "${YELLOW}Session Statistics:${NC}"
  echo -e "  Total time: ${GREEN}${total_elapsed}s${NC} ($(($total_elapsed / 60))m $(($total_elapsed % 60))s)"
  echo -e "  Iterations: ${GREEN}$((final_iteration - 1))${NC}"
  echo -e "  Log file: ${BLUE}$log_file${NC}"
  echo -e ""
  
  # Check for git changes
  local git_changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
  if [ "$git_changes" -eq 0 ]; then
    echo -e "${GREEN}âœ… No changes to commit${NC}"
    echo -e "${BLUE}Session complete - no git action needed${NC}"
    return 0
  fi
  
  # Git approval workflow
  echo -e "${BRIGHT_BLURPLE}ðŸ”„ Git Commit Approval Required${NC}"
  echo -e "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e ""
  echo -e "${YELLOW}Changes detected in working directory:${NC}"
  git status --short
  echo -e ""
  echo -e "${YELLOW}Do you want to commit these changes? ${NC}"
  echo -e "${GREEN}Options:${NC}"
  echo -e "  ${GREEN}y/yes${NC} - Commit changes with auto-generated message"
  echo -e "  ${GREEN}c/custom${NC} - Commit with custom message"
  echo -e "  ${GREEN}r/review${NC} - Review detailed diff first"
  echo -e "  ${GREEN}n/no${NC} - Don't commit (keep changes staged)"
  echo -e "  ${GREEN}d/discard${NC} - Discard all changes (DANGEROUS!)"
  echo -e ""
  
  local commit_choice=$(get_human_input "Your choice:" 60)
  
  case "$commit_choice" in
    "y"|"yes"|"Y"|"YES")
      # Auto-generated commit message
      local commit_msg="Auto-iterate session $session_id: $(git status --porcelain | wc -l | tr -d ' ') files modified

Auto-iterate session completed with $((final_iteration - 1)) iterations.
Total duration: ${total_elapsed}s

Changes made during automated test-fix cycles.
See summary: $summary_file

ðŸ¤– Generated with AICheck auto-iterate mode"
      
      git add -A
      git commit -m "$commit_msg"
      echo -e "${GREEN}âœ… Changes committed successfully${NC}"
      ;;
      
    "c"|"custom"|"C"|"CUSTOM")
      echo -e "${BLUE}Enter custom commit message:${NC}"
      read -p "> " custom_msg
      if [ -n "$custom_msg" ]; then
        git add -A
        git commit -m "$custom_msg

Auto-iterate session: $session_id
Duration: ${total_elapsed}s, Iterations: $((final_iteration - 1))
See summary: $summary_file"
        echo -e "${GREEN}âœ… Changes committed with custom message${NC}"
      else
        echo -e "${YELLOW}Empty message. Changes not committed.${NC}"
      fi
      ;;
      
    "r"|"review"|"R"|"REVIEW")
      echo -e "${BLUE}Reviewing changes...${NC}"
      git diff --cached
      echo -e ""
      echo -e "${YELLOW}Commit these changes? (y/n): ${NC}"
      read -p "> " review_commit
      if [[ "$review_commit" =~ ^[Yy] ]]; then
        git commit -m "Auto-iterate session $session_id

Reviewed and approved changes from automated iteration.
Duration: ${total_elapsed}s, Iterations: $((final_iteration - 1))
See summary: $summary_file"
        echo -e "${GREEN}âœ… Changes committed after review${NC}"
      else
        echo -e "${YELLOW}Changes not committed${NC}"
      fi
      ;;
      
    "d"|"discard"|"D"|"DISCARD")
      echo -e "${RED}âš ï¸  This will discard ALL changes from the session!${NC}"
      echo -e "${YELLOW}Are you absolutely sure? (type 'discard' to confirm): ${NC}"
      read -p "> " confirm_discard
      if [ "$confirm_discard" = "discard" ]; then
        git reset --hard HEAD
        git clean -fd
        echo -e "${RED}All changes discarded${NC}"
      else
        echo -e "${YELLOW}Discard cancelled. Changes preserved.${NC}"
      fi
      ;;
      
    *)
      echo -e "${YELLOW}Changes not committed. Files remain modified.${NC}"
      echo -e "${BLUE}You can commit later using standard git commands${NC}"
      ;;
  esac
  
  echo -e ""
  echo -e "${GREEN}Auto-iterate session complete!${NC}"
  echo -e "${BLUE}Summary: ${BRIGHT_BLURPLE}$summary_file${NC}"
  echo -e "${BLUE}Log: ${BRIGHT_BLURPLE}$log_file${NC}"
}

# Auto-detect new sessions and run startup checks
# auto_session_start_check  # Temporarily disabled for testing

# ===============================================
# MCP Integration Functions
# ===============================================

# Function to detect file type for MCP headers
function detect_file_type() {
  local file="$1"
  local ext="${file##*.}"
  
  case "$ext" in
    py|js|ts|tsx|jsx|sh|bash|zsh) echo "script" ;;
    md|txt|rst) echo "text" ;;
    json|yaml|yml|toml) echo "config" ;;
    *) echo "unknown" ;;
  esac
}

# Function to get appropriate comment prefix for file type
function get_comment_prefix() {
  local file="$1"
  local ext="${file##*.}"
  
  case "$ext" in
    py|sh|bash|zsh|yaml|yml|toml) echo "#" ;;
    js|ts|tsx|jsx) echo "//" ;;
    md|txt|rst) echo "<!--" ;;
    json) echo "" ;; # JSON doesn't support comments
    *) echo "#" ;;
  esac
}

# Function to check if file has MCP header
function has_mcp_header() {
  local file="$1"
  
  if [ ! -f "$file" ]; then
    return 1
  fi
  
  # Check first 15 lines for MCP: pattern (including AICheck_ types)
  head -n 15 "$file" 2>/dev/null | grep -q "MCP:" 2>/dev/null
}

# Function to get current action info for MCP headers
function get_mcp_action_info() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "NoActiveAction")
  local datetime=$(date '+%Y-%m-%d %H:%M:%S %Z')
  
  # If no active action, create a generic identifier
  if [ "$current_action" = "None" ] || [ "$current_action" = "NoActiveAction" ]; then
    current_action="General-$(date '+%Y.%m.%d')"
  fi
  
  echo "$current_action|$datetime"
}

# Function to auto-detect appropriate AICheck MCP type based on context
function get_aicheck_mcp_type() {
  local file="$1"
  local task="$2"
  
  # Auto-assign based on file context
  case "$file" in
    *plan.md|*-plan.md|*/plan.md)
      echo "AICheck_Planner"
      ;;
    *progress.md|*todo.md|*/progress.md|*/todo.md)
      echo "AICheck_Tracker"
      ;;
    *test*.py|*test*.js|*test*.ts|*spec*.js|*spec*.ts|*/tests/*|*/test/*)
      echo "AICheck_Validator"
      ;;
    *.py|*.js|*.ts|*.tsx|*.jsx|*.sh|*.bash|*.zsh|*.go|*.rs|*.c|*.cpp|*.java)
      echo "AICheck_Scoper"
      ;;
    *)
      # Default based on task content
      if [[ "$task" =~ [Tt]est|[Vv]alidat|[Vv]erif ]]; then
        echo "AICheck_Validator"
      elif [[ "$task" =~ [Pp]lan|[Dd]esign|[Aa]rchitect ]]; then
        echo "AICheck_Planner"
      elif [[ "$task" =~ [Tt]rack|[Pp]rogress|[Uu]pdate ]]; then
        echo "AICheck_Tracker"
      else
        echo "AICheck_Scoper"
      fi
      ;;
  esac
}

# Function to get AICheck MCP template with context-specific behavior
function get_mcp_template() {
  local task="$1"
  local file="$2"
  local comment_prefix="$3"
  local mcp_type="${4:-$(get_aicheck_mcp_type "$file" "$task")}"
  
  # Get action and datetime info
  local action_info=$(get_mcp_action_info)
  local action_id=$(echo "$action_info" | cut -d'|' -f1)
  local datetime=$(echo "$action_info" | cut -d'|' -f2)
  
  # Base AICheck header
  echo "${comment_prefix} MCP: $mcp_type"
  echo "${comment_prefix} Action: $action_id"
  echo "${comment_prefix} DateTime: $datetime"
  echo "${comment_prefix} Task: $task"
  if [ -n "$file" ]; then
    echo "${comment_prefix} File: $file"
  fi
  
  # Context-specific instructions
  case "$mcp_type" in
    "AICheck_Planner")
      echo "${comment_prefix} Before coding, outline the steps you plan to take to complete this task."
      echo "${comment_prefix} Follow the approved action plan and document any scope changes."
      ;;
    "AICheck_Tracker")
      echo "${comment_prefix} Track progress and document decisions as you work."
      echo "${comment_prefix} Update task status and log any blockers or dependencies."
      ;;
    "AICheck_Validator")
      echo "${comment_prefix} After editing, summarize what was changed, why, and how it was validated."
      echo "${comment_prefix} Ensure all tests pass and document verification steps."
      ;;
    "AICheck_Scoper")
      echo "${comment_prefix} You may only modify this file. Stay within the current action scope."
      echo "${comment_prefix} Follow the approved plan and avoid scope creep."
      ;;
    *)
      echo "${comment_prefix} Follow the approved plan and stay within action scope."
      ;;
  esac
}

# Function to inject MCP header into file
function inject_mcp_header() {
  local file="$1"
  local task="$2"
  
  if [ ! -f "$file" ]; then
    echo -e "${RED}âœ— File not found: $file${NC}"
    return 1
  fi
  
  if has_mcp_header "$file"; then
    echo -e "${YELLOW}âš  MCP header already exists in $file${NC}"
    return 0
  fi
  
  local comment_prefix=$(get_comment_prefix "$file")
  local header=$(get_mcp_template "$task" "$file" "$comment_prefix")
  
  # Create backup
  cp "$file" "${file}.mcp-backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
  
  # Inject header at top of file
  if [ "$comment_prefix" = "<!--" ]; then
    # For markdown/HTML files, close the comment
    header="$header -->"
  fi
  
  local temp_file=$(mktemp)
  echo "$header" > "$temp_file"
  echo "" >> "$temp_file"
  cat "$file" >> "$temp_file"
  mv "$temp_file" "$file"
  
  echo -e "${GREEN}âœ“ Injected MCP header into $file${NC}"
  return 0
}

# Function to extract MCP header from file
function extract_mcp_header() {
  local file="$1"
  
  if [ ! -f "$file" ]; then
    echo "File not found: $file"
    return 1
  fi
  
  # Extract first 15 lines that contain MCP-related content
  head -n 15 "$file" 2>/dev/null | grep -E "(MCP|Action|DateTime|Task|File):" 2>/dev/null || echo "No MCP header found"
}

# Function to validate files for MCP headers (used by pre-commit hook)
function validate_mcp_headers() {
  local files=("$@")
  local missing_files=()
  
  for file in "${files[@]}"; do
    # Skip non-existent files
    if [ ! -f "$file" ]; then
      continue
    fi
    
    # Skip certain file types
    local ext="${file##*.}"
    case "$ext" in
      png|jpg|jpeg|gif|svg|ico|pdf|zip|tar|gz|bz2|dmg|pkg) continue ;;
    esac
    
    if ! has_mcp_header "$file"; then
      missing_files+=("$file")
    fi
  done
  
  if [ ${#missing_files[@]} -gt 0 ]; then
    echo -e "${RED}âœ— Missing MCP headers in:${NC}"
    for file in "${missing_files[@]}"; do
      echo "  $file"
    done
    echo -e "${YELLOW}Run: ./aicheck mcp edit${NC}"
    return 1
  fi
  
  echo -e "${GREEN}âœ“ All files have MCP headers${NC}"
  return 0
}

# Function to install smart pre-commit hook
function install_smart_precommit_hook() {
  if [ ! -d .git ]; then
    echo -e "${YELLOW}âš  Not in a git repository${NC}"
    return 1
  fi
  
  mkdir -p .git/hooks
  
  cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
# AICheck Smart Pre-commit Hook

# Function to detect project environment (minimal version for hook)
detect_hook_environment() {
  local env_info=""
  
  # Python project detection
  [ -f "pyproject.toml" ] && env_info="${env_info}poetry,"
  [ -f "requirements.txt" ] && env_info="${env_info}pip,"
  [ -f "setup.py" ] && env_info="${env_info}setuptools,"
  
  # Node project detection
  [ -f "package.json" ] && env_info="${env_info}node,"
  
  # Testing tools
  [ -f "pytest.ini" ] || [ -f ".pytest.ini" ] && env_info="${env_info}pytest,"
  [ -f "jest.config.js" ] || [ -f "jest.config.ts" ] && env_info="${env_info}jest,"
  
  # Linting tools
  [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] && env_info="${env_info}eslint,"
  [ -f "pyproject.toml" ] && grep -q "black" pyproject.toml 2>/dev/null && env_info="${env_info}black,"
  [ -f "pyproject.toml" ] && grep -q "ruff" pyproject.toml 2>/dev/null && env_info="${env_info}ruff,"
  
  echo "${env_info%,}"  # Remove trailing comma
}

# Get staged files
staged_files=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$staged_files" ]; then
  exit 0
fi

# Detect project environment
project_env=$(detect_hook_environment)
echo "ðŸ” Detected environment: ${project_env:-none}"

# Convert staged files to arrays by type
python_files=()
js_files=()
ts_files=()
all_files=()

while IFS= read -r file; do
  all_files+=("$file")
  case "${file##*.}" in
    py) python_files+=("$file") ;;
    js|jsx) js_files+=("$file") ;;
    ts|tsx) ts_files+=("$file") ;;
  esac
done <<< "$staged_files"

# Track if any checks fail
failed=0

# Run appropriate checks based on project type and staged files

# Python checks
if [ ${#python_files[@]} -gt 0 ] && [[ "$project_env" =~ "black" ]] && command -v black >/dev/null 2>&1; then
  echo -n "âš« Black formatting check... "
  if black --check "${python_files[@]}" >/dev/null 2>&1; then
    echo "âœ…"
  else
    echo "âŒ"
    echo "  â†’ Run: black ${python_files[@]}"
    failed=1
  fi
fi

if [ ${#python_files[@]} -gt 0 ] && [[ "$project_env" =~ "ruff" ]] && command -v ruff >/dev/null 2>&1; then
  echo -n "ðŸ¦€ Ruff linting check... "
  if ruff check "${python_files[@]}" >/dev/null 2>&1; then
    echo "âœ…"
  else
    echo "âŒ"
    echo "  â†’ Run: ruff check --fix ${python_files[@]}"
    failed=1
  fi
fi

# JavaScript/TypeScript checks
if ([ ${#js_files[@]} -gt 0 ] || [ ${#ts_files[@]} -gt 0 ]) && [[ "$project_env" =~ "eslint" ]]; then
  echo -n "ðŸ“ ESLint check... "
  files_to_lint=("${js_files[@]}" "${ts_files[@]}")
  if npx eslint "${files_to_lint[@]}" >/dev/null 2>&1; then
    echo "âœ…"
  else
    echo "âŒ"
    echo "  â†’ Run: npx eslint --fix ${files_to_lint[@]}"
    failed=1
  fi
fi

# Run quick tests if files in test directories are modified
if [[ "$staged_files" =~ (test_|_test\.|test/|tests/|__tests__/) ]]; then
  echo "ðŸ§ª Test files modified, running quick test check..."
  
  if [[ "$project_env" =~ "pytest" ]] && command -v pytest >/dev/null 2>&1; then
    # Run only tests for modified files
    test_files=$(echo "$staged_files" | grep -E "(test_|_test\.py)")
    if [ -n "$test_files" ]; then
      echo -n "  Python tests... "
      if pytest -x $test_files >/dev/null 2>&1; then
        echo "âœ…"
      else
        echo "âŒ"
        failed=1
      fi
    fi
  fi
  
  if [[ "$project_env" =~ "jest" ]] && [ -f "package.json" ]; then
    # Run only tests for modified files
    test_files=$(echo "$staged_files" | grep -E "(test\.|\.test\.|spec\.|\.spec\.)")
    if [ -n "$test_files" ]; then
      echo -n "  JavaScript tests... "
      if npx jest --findRelatedTests $test_files >/dev/null 2>&1; then
        echo "âœ…"
      else
        echo "âŒ"
        failed=1
      fi
    fi
  fi
fi

# MCP header validation (if AICheck is present)
if [ -f "./aicheck" ]; then
  echo -n "ðŸ“‹ MCP header validation... "
  if ./aicheck mcp validate "${all_files[@]}" >/dev/null 2>&1; then
    echo "âœ…"
  else
    echo "âŒ"
    echo "  â†’ Run: ./aicheck mcp edit"
    failed=1
  fi
fi

# Summary
if [ $failed -eq 0 ]; then
  echo ""
  echo "âœ… All pre-commit checks passed!"
  exit 0
else
  echo ""
  echo "âŒ Pre-commit checks failed. Please fix the issues above."
  echo ""
  echo "To bypass checks (not recommended): git commit --no-verify"
  exit 1
fi
EOF
  
  chmod +x .git/hooks/pre-commit
  echo -e "${GREEN}âœ“ Smart pre-commit hook installed${NC}"
  echo -e "${CYAN}The hook will run appropriate checks based on your project type and staged files.${NC}"
}

# Keep the original function name for backward compatibility
function install_mcp_precommit_hook() {
  install_smart_precommit_hook
}

# Function for guided MCP onboarding
function mcp_edit_onboarding() {
  echo -e "${BRIGHT_BLURPLE}AICheck MCP Editor Integration${NC}"
  echo -e ""
  
  # Auto-install pre-commit hook if needed
  if [ -d .git ] && [ ! -f .git/hooks/pre-commit ]; then
    echo -e "${BLUE}Installing pre-commit hook...${NC}"
    install_mcp_precommit_hook
    echo -e ""
  fi
  
  # Get file to edit
  read -p "Which file are you editing? > " filepath
  
  if [ -z "$filepath" ]; then
    echo -e "${RED}âœ— No file specified${NC}"
    return 1
  fi
  
  if [ ! -f "$filepath" ]; then
    echo -e "${RED}âœ— File not found: $filepath${NC}"
    return 1
  fi
  
  # Check if already has MCP header
  if has_mcp_header "$filepath"; then
    echo -e "${GREEN}âœ“ File already has MCP header${NC}"
    echo -e "${BLUE}Current header:${NC}"
    extract_mcp_header "$filepath"
    echo -e ""
    
    read -p "Continue with this header? (y/N) > " continue_with_existing
    if [[ ! "$continue_with_existing" =~ ^[Yy]$ ]]; then
      return 0
    fi
  else
    # Get task description
    read -p "Describe the task: > " task
    
    if [ -z "$task" ]; then
      task="File modification"
    fi
    
    # Select MCP type
    echo -e "${BLUE}Select MCP type:${NC}"
    echo "1) task_tracker - Track task goals and progress"
    echo "2) scope_limiter - Limit changes to specific file"
    echo "3) code_plan_enforcer - Require planning before coding"
    echo "4) output_validator - Require validation summary"
    read -p "Choice (1-4): > " mcp_choice
    
    case "$mcp_choice" in
      1) mcp_type="task_tracker" ;;
      2) mcp_type="scope_limiter" ;;
      3) mcp_type="code_plan_enforcer" ;;
      4) mcp_type="output_validator" ;;
      *) mcp_type="task_tracker" ;;
    esac
    
    # Inject MCP header
    if inject_mcp_header "$mcp_type" "$filepath" "$task"; then
      echo -e ""
    else
      return 1
    fi
  fi
  
  # Show Claude/Cursor prompt
  echo -e "${BRIGHT_BLURPLE}ðŸ“‹ Claude/Cursor Prompt:${NC}"
  echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  extract_mcp_header "$filepath"
  echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo -e ""
  echo -e "${YELLOW}ðŸ‘‰ Copy the MCP prompt above into your AI editor${NC}"
  echo -e "${YELLOW}   or confirm it appears at the top of your file.${NC}"
}

# Function to detect editor type
function detect_editor() {
  local editor="$1"
  local editor_lower=$(echo "$editor" | tr '[:upper:]' '[:lower:]')
  case "$editor_lower" in
    claude) echo "claude" ;;
    cursor) echo "cursor" ;;
    copilot|cody|gemini|other) echo "generic" ;;
    *) echo "generic" ;;
  esac
}

# Function for universal editor integration
function launch_ai_editor() {
  local editor_type=$(detect_editor "$1")
  local file="$2"
  shift 2
  local extra_args=("$@")
  
  if [ -z "$file" ]; then
    echo -e "${RED}âœ— No file specified${NC}"
    echo "Usage: ./aicheck edit <editor> <file>"
    return 1
  fi
  
  if [ ! -f "$file" ]; then
    echo -e "${RED}âœ— File not found: $file${NC}"
    return 1
  fi
  
  # Ensure MCP header exists
  if ! has_mcp_header "$file"; then
    echo -e "${YELLOW}âš  File missing MCP header${NC}"
    echo -e "${BLUE}Running MCP onboarding...${NC}"
    echo -e ""
    
    # Auto-inject a basic AICheck header
    inject_mcp_header "$file" "Edit file with AI assistance"
  fi
  
  case "$editor_type" in
    "claude")
      echo -e "${BRIGHT_BLURPLE}Claude Integration${NC}"
      echo -e "${BLUE}MCP Prompt to use:${NC}"
      echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
      extract_mcp_header "$file"
      echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
      echo -e ""
      echo -e "${YELLOW}Update this script with your Claude CLI command:${NC}"
      echo -e "${GRAY}# claude_cli --system-prompt \"\$(./aicheck mcp prompt \"$file\")\" --input \"$file\" ${extra_args[*]}${NC}"
      ;;
      
    "cursor")
      echo -e "${BRIGHT_BLURPLE}Cursor Integration${NC}"
      echo -e "${BLUE}MCP Prompt for Cursor:${NC}"
      echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
      extract_mcp_header "$file"
      echo -e "${GRAY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
      echo -e ""
      echo -e "${YELLOW}Paste this into Cursor's context or confirm it's at the top of your file.${NC}"
      echo -e "${GRAY}# To launch Cursor: cursor \"$file\"${NC}"
      ;;
      
    "generic")
      echo -e "${BRIGHT_BLURPLE}Generic AI Editor Integration${NC}"
      echo -e "${BLUE}MCP Header in file:${NC}"
      extract_mcp_header "$file"
      echo -e ""
      echo -e "${YELLOW}Opening $file for editing with $1${NC}"
      echo -e "${GRAY}# Add your editor launch command here${NC}"
      ;;
  esac
}

# Main command handling

# Validate single active action principle before executing commands
validate_single_active_action "$CMD"

case "$CMD" in
  "new")
    # Shortcut for action new
    create_action "$1"
    ;;
  "active"|"ACTIVE")
    # Shortcut for action set
    set_active_action "$1"
    ;;
  "complete"|"Complete"|"COMPLETE")
    # Shortcut for action complete
    complete_action "$1"
    ;;
  "status")
    # Show current status
    show_status
    ;;
  "stuck")
    # Get unstuck help
    show_status
    echo -e ""
    echo -e "${BRIGHT_BLURPLE}ðŸ†˜ Getting Unstuck${NC}"
    echo -e ""
    echo -e "${YELLOW}If you're feeling lost, here's what to check:${NC}"
    echo -e "1. ${GREEN}./aicheck status${NC} - See current action status"
    echo -e "2. ${GREEN}./aicheck focus${NC} - Check for scope creep"
    echo -e "3. ${GREEN}./aicheck cleanup${NC} - Clean up and optimize"
    echo -e "4. ${GREEN}./aicheck deploy${NC} - Pre-deployment check"
    echo -e ""
    echo -e "${PURPLE}Need to start fresh?${NC}"
    echo -e "â€¢ ${GREEN}./aicheck new ActionName${NC} - Create new action"
    echo -e "â€¢ ${GREEN}./aicheck ACTIVE ActionName${NC} - Switch to action"
    ;;
  "focus")
    # Check for scope creep and compliance issues
    enforce_action_boundaries
    ;;
  "cleanup")
    # Clean up and optimize
    cleanup_and_optimize
    ;;
  "deploy")
    # Shortcut for deploy-check
    $0 deploy-check
    ;;
  "usage")
    # Show AI usage and costs
    mcp__aicheck__aicheck_analyzeCosts 2>/dev/null || echo -e "${YELLOW}Usage tracking not available - MCP server not connected${NC}"
    ;;
  "auto-iterate"|"iterate"|"auto")
    # Auto-iterate mode: test, analyze, fix, repeat
    auto_iterate "$1" "$2"
    ;;
  "version"|"--version")
    # Show version information
    show_version
    ;;
  "mcp")
    # MCP integration commands
    case "$1" in
      "edit")
        # Guided MCP onboarding
        mcp_edit_onboarding
        ;;
      "validate")
        # Validate MCP headers in files
        shift
        validate_mcp_headers "$@"
        ;;
      "install-hook")
        # Install pre-commit hook
        install_mcp_precommit_hook
        ;;
      "prompt")
        # Extract MCP prompt from file
        if [ -z "$2" ]; then
          echo -e "${RED}âœ— No file specified${NC}"
          echo "Usage: ./aicheck mcp prompt <file>"
          exit 1
        fi
        extract_mcp_header "$2"
        ;;
      *)
        echo -e "${BRIGHT_BLURPLE}AICheck MCP Integration${NC}"
        echo -e ""
        echo -e "${GREEN}Available MCP commands:${NC}"
        echo -e "  ${GREEN}./aicheck mcp edit${NC}         - Guided MCP header setup"
        echo -e "  ${GREEN}./aicheck mcp validate <files>${NC} - Validate MCP headers"
        echo -e "  ${GREEN}./aicheck mcp install-hook${NC}  - Install pre-commit hook"
        echo -e "  ${GREEN}./aicheck mcp prompt <file>${NC} - Extract MCP prompt"
        echo -e ""
        echo -e "${BLUE}Editor integration:${NC}"
        echo -e "  ${GREEN}./aicheck edit claude <file>${NC}  - Claude integration"
        echo -e "  ${GREEN}./aicheck edit cursor <file>${NC}  - Cursor integration"
        echo -e "  ${GREEN}./aicheck edit <editor> <file>${NC} - Generic editor"
        ;;
    esac
    ;;
  "edit")
    # Universal AI editor integration
    if [ -z "$1" ]; then
      echo -e "${RED}âœ— No editor specified${NC}"
      echo "Usage: ./aicheck edit <editor> <file>"
      echo "Editors: claude, cursor, copilot, cody, gemini, other"
      exit 1
    fi
    launch_ai_editor "$@"
    ;;
  *)
    echo -e "${RED}âŒ Unknown command: $CMD${NC}"
    echo -e ""
    echo -e "${BRIGHT_BLURPLE}Try these instead:${NC}"
    echo -e "  ${GREEN}./aicheck stuck${NC}     - Get help and see what's happening"
    echo -e "  ${GREEN}./aicheck focus${NC}     - Check if you're on track"
    echo -e "  ${GREEN}./aicheck cleanup${NC}   - Clean up files and optimize"
    echo -e "  ${GREEN}./aicheck version${NC}   - See all available commands"
    ;;
esac
