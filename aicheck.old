#!/bin/bash

# AICheck command script
# Provides the core functionality for AICheck MCP
# Version: 5.0.0
# Last Updated: 2025-01-06

set -e

# AICheck version info
AICHECK_VERSION="6.0.0"
GITHUB_REPO="fieldjoshua/AICheck_MCP"
GITHUB_RAW_BASE="https://raw.githubusercontent.com/${GITHUB_REPO}/main"

CMD=$1
shift || true
ARGS=$@

# Function to show version information
function show_version() {
  echo -e "${BRIGHT_BLURPLE}AICheck MCP${NC}"
  echo -e "Version: ${GREEN}${AICHECK_VERSION}${NC}"
  echo -e "Repository: ${GITHUB_REPO}"
  echo -e ""
  echo -e "${BRIGHT_BLURPLE}📋 Your Commands:${NC}"
  echo -e "  ${GREEN}./aicheck status${NC}         - Show detailed status"
  echo -e "  ${GREEN}./aicheck focus${NC}          - Check for scope creep"
  echo -e "  ${GREEN}./aicheck stuck${NC}          - Get unstuck when confused"
  echo -e "  ${GREEN}./aicheck deploy${NC}         - Pre-deployment validation"
  echo -e "  ${GREEN}./aicheck auto-iterate${NC}   - Automated test-fix-test cycles"
  echo -e "  ${GREEN}./aicheck new${NC}            - Create a new action"
  echo -e "  ${GREEN}./aicheck ACTIVE${NC}         - Set the ACTIVE action"
  echo -e "  ${GREEN}./aicheck complete${NC}       - Complete the ACTIVE action"
  echo -e "  ${GREEN}./aicheck cleanup${NC}        - Optimize and fix compliance"
  echo -e "  ${GREEN}./aicheck usage${NC}          - See AI usage and costs"
  echo -e ""
  echo -e "${YELLOW}💡 Only one action can be ACTIVE at a time.${NC}"
}

# Function to check for updates
function check_for_updates() {
  echo -e "${BRIGHT_BLURPLE}Checking for updates...${NC}"
  
  # Get remote version
  local remote_version=$(curl -s "${GITHUB_RAW_BASE}/aicheck" | grep "AICHECK_VERSION=" | head -1 | cut -d'"' -f2)
  
  if [ -z "$remote_version" ]; then
    echo -e "${YELLOW}⚠ Could not check remote version${NC}"
    return 1
  fi
  
  echo -e "Local version:  ${GREEN}${AICHECK_VERSION}${NC}"
  echo -e "Remote version: ${GREEN}${remote_version}${NC}"
  
  if [ "$AICHECK_VERSION" != "$remote_version" ]; then
    echo -e "${YELLOW}🔄 Update available: ${remote_version}${NC}"
    return 0
  else
    echo -e "${GREEN}✓ AICheck is up to date${NC}"
    return 1
  fi
}

# Function to backup current aicheck command
function backup_aicheck() {
  local script_path="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
  local backup_path="${script_path}.backup.$(date +%Y%m%d_%H%M%S)"
  
  if cp "$script_path" "$backup_path" 2>/dev/null; then
    echo -e "${GREEN}✓ Backup created: $(basename "$backup_path")${NC}"
    echo "$backup_path"
  else
    echo -e "${YELLOW}⚠ Could not create backup${NC}"
    return 1
  fi
}

# Function to update aicheck command itself
function update_aicheck_command() {
  echo -e "${BRIGHT_BLURPLE}Updating AICheck command...${NC}"
  
  # Get the script path
  local script_path="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
  
  # Create backup
  local backup_path=$(backup_aicheck)
  if [ $? -ne 0 ]; then
    echo -e "${RED}✗ Failed to create backup - aborting update${NC}"
    return 1
  fi
  
  # Download new version to temporary file
  local temp_file=$(mktemp)
  if curl -sL "${GITHUB_RAW_BASE}/aicheck" -o "$temp_file"; then
    # Verify the download is valid
    if bash -n "$temp_file" 2>/dev/null; then
      # Make sure it's executable and replace current script
      chmod +x "$temp_file"
      if mv "$temp_file" "$script_path"; then
        echo -e "${GREEN}✓ AICheck command updated successfully${NC}"
        echo -e "${BRIGHT_BLURPLE}Restart your session or run the command again to use the new version${NC}"
        return 0
      else
        echo -e "${RED}✗ Failed to replace aicheck command${NC}"
        # Restore from backup
        mv "$backup_path" "$script_path"
        echo -e "${YELLOW}⚠ Restored from backup${NC}"
        rm -f "$temp_file"
        return 1
      fi
    else
      echo -e "${RED}✗ Downloaded file is not valid - aborting update${NC}"
      rm -f "$temp_file"
      return 1
    fi
  else
    echo -e "${RED}✗ Failed to download aicheck command${NC}"
    rm -f "$temp_file"
    return 1
  fi
}

# Function to update AICheck rules
function update_rules() {
  echo -e "${BRIGHT_BLURPLE}Updating AICheck RULES.md...${NC}"
  
  # Make RULES.md writable if it exists
  if [ -f ".aicheck/RULES.md" ]; then
    chmod +w .aicheck/RULES.md
  fi
  
  # Download latest RULES.md
  if curl -sL "${GITHUB_RAW_BASE}/RULES.md" -o .aicheck/RULES.md; then
    echo -e "${GREEN}✓ RULES.md updated successfully${NC}"
    chmod 444 .aicheck/RULES.md  # Make read-only again
  else
    echo -e "${RED}✗ Failed to update RULES.md - check internet connection${NC}"
    return 1
  fi
}

# Function to update everything (rules + command)
function update_all() {
  echo -e "${BRIGHT_BLURPLE}Updating AICheck system...${NC}"
  echo ""
  
  # Check if updates are available
  if ! check_for_updates; then
    echo -e "${GREEN}✓ No updates needed${NC}"
    return 0
  fi
  
  echo ""
  local rules_updated=false
  local command_updated=false
  
  # Update RULES.md
  if update_rules; then
    rules_updated=true
  fi
  
  echo ""
  
  # Update aicheck command
  if update_aicheck_command; then
    command_updated=true
  fi
  
  echo ""
  echo -e "${BRIGHT_BLURPLE}Update Summary:${NC}"
  echo -e "RULES.md: $([ "$rules_updated" = true ] && echo -e "${GREEN}✓ Updated${NC}" || echo -e "${RED}✗ Failed${NC}")"
  echo -e "AICheck command: $([ "$command_updated" = true ] && echo -e "${GREEN}✓ Updated${NC}" || echo -e "${RED}✗ Failed${NC}")"
  
  if [ "$rules_updated" = true ] || [ "$command_updated" = true ]; then
    echo -e "${GREEN}✓ AICheck system updated successfully${NC}"
    if [ "$command_updated" = true ]; then
      echo -e "${YELLOW}⚠ Please restart your session or run the command again${NC}"
    fi
  else
    echo -e "${RED}✗ Update failed${NC}"
    return 1
  fi
}

GREEN="\033[0;32m"
NEON_BLURPLE="\033[38;5;99m"      # Neon blurple highlight color
BRIGHT_BLURPLE="\033[38;5;135m"   # Bright blurple for text
YELLOW="\033[0;33m"
RED="\033[0;31m"
CYAN="\033[0;36m"
NC="\033[0m" # No Color

# Function to automatically detect context pollution
function detect_context_pollution() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  local pollution_score=0
  local warnings=()
  
  # Check for multiple active actions
  if [ -d ".aicheck/actions" ]; then
    local active_count=$(find .aicheck/actions -name "status.txt" -exec grep -l "ActiveAction" {} \; 2>/dev/null | wc -l | tr -d ' ')
    if [ "$active_count" -gt 1 ]; then
      pollution_score=$((pollution_score + 30))
      warnings+=("Multiple active actions detected ($active_count)")
    fi
  fi
  
  # Check for excessive Claude interaction logs in the last hour
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    local interaction_dir=".aicheck/actions/$dir_name/supporting_docs/claude-interactions"
    if [ -d "$interaction_dir" ]; then
      local recent_interactions=$(find "$interaction_dir" -name "*.md" -mmin -60 2>/dev/null | wc -l | tr -d ' ')
      if [ "$recent_interactions" -gt 10 ]; then
        pollution_score=$((pollution_score + 20))
        warnings+=("High interaction frequency: $recent_interactions in last hour")
      fi
    fi
  fi
  
  # Check for uncommitted changes across multiple directories
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local changed_dirs=$(git status --porcelain 2>/dev/null | awk '{print $2}' | xargs dirname | sort -u | wc -l | tr -d ' ')
    if [ "$changed_dirs" -gt 3 ]; then
      pollution_score=$((pollution_score + 15))
      warnings+=("Changes scattered across $changed_dirs directories")
    fi
  fi
  
  echo "$pollution_score"
  if [ ${#warnings[@]} -gt 0 ]; then
    echo "WARNINGS:"
    printf '%s\n' "${warnings[@]}"
  fi
}

# Function to automatically clear context (with approval for destructive actions)
function clear_context() {
  local force=$1
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Context Clear${NC}"
  echo -e "Analyzing current context state..."
  
  local pollution_data=$(detect_context_pollution)
  local pollution_score=$(echo "$pollution_data" | head -1)
  local warnings=$(echo "$pollution_data" | tail -n +2)
  
  echo -e "Context pollution score: ${GREEN}$pollution_score/100${NC}"
  if [ -n "$warnings" ]; then
    echo -e "${YELLOW}$warnings${NC}"
  fi
  
  # Automated safe actions (no approval needed)
  echo -e "\n${BRIGHT_BLURPLE}Performing automated context cleanup...${NC}"
  
  # Clean up temp files
  find . -name "*.tmp" -o -name "*.temp" -o -name ".DS_Store" 2>/dev/null | xargs rm -f 2>/dev/null || true
  echo -e "${GREEN}✓ Cleaned temporary files${NC}"
  
  # Reset any exec mode state safely
  if [ "$current_action" = "AICheckExec" ] && [ -f ".aicheck/previous_action" ]; then
    local previous=$(cat .aicheck/previous_action)
    echo "$previous" > .aicheck/current_action
    rm .aicheck/previous_action
    echo -e "${GREEN}✓ Restored from exec mode to: $previous${NC}"
  fi
  
  # Archive old interaction logs (keep last 5 per action)
  if [ -d ".aicheck/actions" ]; then
    find .aicheck/actions -name "claude-interactions" -type d | while read dir; do
      if [ $(ls "$dir"/*.md 2>/dev/null | wc -l) -gt 5 ]; then
        mkdir -p "$dir/archive"
        ls -t "$dir"/*.md 2>/dev/null | tail -n +6 | xargs mv -t "$dir/archive/" 2>/dev/null || true
      fi
    done
    echo -e "${GREEN}✓ Archived old interaction logs${NC}"
  fi
  
  # Actions requiring approval
  local needs_approval=false
  local approval_actions=()
  
  if [ "$pollution_score" -gt 50 ]; then
    needs_approval=true
    approval_actions+=("Reset all active actions to 'Not Started'")
    approval_actions+=("Clear all uncommitted git changes")
    approval_actions+=("Reset current action to 'None'")
  fi
  
  if [ "$force" != "--force" ] && [ "$needs_approval" = true ]; then
    echo -e "\n${YELLOW}The following actions require human approval:${NC}"
    printf '  - %s\n' "${approval_actions[@]}"
    echo -e "\n${YELLOW}Run './aicheck context clear --force' to proceed with destructive actions${NC}"
    echo -e "${YELLOW}Or manually address the issues listed above${NC}"
    return 0
  fi
  
  if [ "$force" = "--force" ]; then
    echo -e "\n${RED}Performing destructive context reset...${NC}"
    
    # Reset multiple active actions
    if [ -d ".aicheck/actions" ]; then
      find .aicheck/actions -name "status.txt" -exec sed -i "" 's/ActiveAction/Not Started/g' {} \; 2>/dev/null
      echo -e "${GREEN}✓ Reset all actions to 'Not Started'${NC}"
    fi
    
    # Reset current action
    echo "None" > .aicheck/current_action
    echo -e "${GREEN}✓ Reset current action to 'None'${NC}"
    
    echo -e "${RED}⚠ Destructive context reset completed${NC}"
    echo -e "${YELLOW}You may need to manually restore your intended active action${NC}"
  fi
  
  echo -e "\n${GREEN}✓ Context cleanup completed${NC}"
}

# Function to automatically compact context (summarize and preserve essentials)
function compact_context() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Context Compact${NC}"
  echo -e "Compacting context for action: ${GREEN}$current_action${NC}"
  
  if [ "$current_action" = "None" ] || [ "$current_action" = "AICheckExec" ]; then
    echo -e "${YELLOW}No active action to compact${NC}"
    return 0
  fi
  
  local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir=".aicheck/actions/$dir_name"
  
  if [ ! -d "$action_dir" ]; then
    echo -e "${RED}Action directory not found: $action_dir${NC}"
    return 1
  fi
  
  # Automated compaction (no approval needed)
  echo -e "\n${BRIGHT_BLURPLE}Performing automated compaction...${NC}"
  
  # Create compact summary
  local timestamp=$(date +"%Y-%m-%d_%H%M%S")
  local summary_file="$action_dir/context-compact-$timestamp.md"
  
  cat > "$summary_file" << COMPACT
# Context Compact: $current_action

**Generated:** $(date)
**Action Status:** $(cat "$action_dir/status.txt" 2>/dev/null || echo "Unknown")

## Action Summary

$(head -20 "$action_dir/$dir_name-plan.md" 2>/dev/null || echo "Plan not found")

## Recent Progress

$(tail -10 "$action_dir/progress.md" 2>/dev/null || echo "No progress logged")

## Key Files Modified (Last 24h)

$(if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  git log --since="24 hours ago" --name-only --pretty=format: | sort -u | head -10
else
  echo "Not in git repository"
fi)

## Dependencies

$(if [ -f "documentation/dependencies/dependency_index.md" ]; then
  grep "$current_action" documentation/dependencies/dependency_index.md || echo "No dependencies found"
else
  echo "No dependency index found"
fi)

## Context State

- Interaction logs: $(find "$action_dir/supporting_docs/claude-interactions" -name "*.md" 2>/dev/null | wc -l | tr -d ' ') files
- Git changes: $(git status --porcelain 2>/dev/null | wc -l | tr -d ' ') files
- Action progress: $(grep "Progress:" "$action_dir/$dir_name-plan.md" 2>/dev/null | cut -d':' -f2 | tr -d ' ' || echo "Unknown")
COMPACT

  echo -e "${GREEN}✓ Created compact summary: $(basename "$summary_file")${NC}"
  
  # Archive older interaction logs (keep last 3)
  local interaction_dir="$action_dir/supporting_docs/claude-interactions"
  if [ -d "$interaction_dir" ]; then
    local log_count=$(ls "$interaction_dir"/*.md 2>/dev/null | wc -l | tr -d ' ')
    if [ "$log_count" -gt 3 ]; then
      mkdir -p "$interaction_dir/archive"
      ls -t "$interaction_dir"/*.md 2>/dev/null | tail -n +4 | xargs mv -t "$interaction_dir/archive/" 2>/dev/null || true
      echo -e "${GREEN}✓ Archived $(($log_count - 3)) older interaction logs${NC}"
    fi
  fi
  
  # Update progress tracking
  local current_progress=$(grep "Progress:" "$action_dir/$dir_name-plan.md" 2>/dev/null | cut -d':' -f2 | tr -d ' %' || echo "0")
  echo "$(date +"%Y-%m-%d") - Context compacted (Progress: $current_progress%)" >> "$action_dir/progress.md"
  
  echo -e "${GREEN}✓ Context compaction completed${NC}"
  echo -e "${BRIGHT_BLURPLE}Summary: $summary_file${NC}"
}

# Function to track and analyze usage costs
function analyze_usage_costs() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Usage & Cost Analysis${NC}"
  echo -e "Current Action: ${GREEN}$current_action${NC}"
  
  # Track interaction frequency and estimate costs
  local total_interactions=0
  local today_interactions=0
  local thinking_usage=0
  local estimated_cost=0
  
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    local interaction_dir=".aicheck/actions/$dir_name/supporting_docs/claude-interactions"
    
    if [ -d "$interaction_dir" ]; then
      total_interactions=$(find "$interaction_dir" -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
      today_interactions=$(find "$interaction_dir" -name "*.md" -mtime -1 2>/dev/null | wc -l | tr -d ' ')
      
      # Analyze for "think harder" usage patterns
      thinking_usage=$(find "$interaction_dir" -name "*.md" -exec grep -l "think\|analyze\|complex" {} \; 2>/dev/null | wc -l | tr -d ' ')
    fi
  fi
  
  # Estimate costs based on Claude Code subscription model
  # Rough estimation: Claude Code subscription provides predictable costs
  local daily_limit=100
  local usage_percent=$((today_interactions * 100 / daily_limit))
  
  echo -e "\n${BRIGHT_BLURPLE}Usage Statistics:${NC}"
  echo -e "Total interactions: ${GREEN}$total_interactions${NC}"
  echo -e "Today's interactions: ${GREEN}$today_interactions${NC}"
  echo -e "Thinking-intensive: ${GREEN}$thinking_usage${NC} ($(($thinking_usage * 100 / ($total_interactions + 1)))%)"
  echo -e "Daily usage: ${GREEN}$usage_percent%${NC} of typical daily limit"
  
  # Context size analysis
  local context_files=$(find . -name "*.md" -o -name "*.js" -o -name "*.py" -o -name "*.ts" | wc -l | tr -d ' ')
  local large_files=$(find . -name "*.md" -o -name "*.js" -o -name "*.py" -o -name "*.ts" -size +10k | wc -l | tr -d ' ')
  
  echo -e "\n${BRIGHT_BLURPLE}Context Optimization:${NC}"
  echo -e "Total context files: ${GREEN}$context_files${NC}"
  echo -e "Large files (>10k): ${YELLOW}$large_files${NC}"
  
  if [ "$large_files" -gt 5 ]; then
    echo -e "${YELLOW}⚠ Consider context optimization for large files${NC}"
  fi
  
  # Usage recommendations
  echo -e "\n${BRIGHT_BLURPLE}Optimization Recommendations:${NC}"
  
  if [ "$usage_percent" -gt 80 ]; then
    echo -e "${YELLOW}• High daily usage - consider context compaction${NC}"
    echo -e "${YELLOW}• Run './aicheck context compact' to reduce context size${NC}"
  fi
  
  if [ "$thinking_usage" -gt 5 ]; then
    echo -e "${YELLOW}• High thinking usage - consider graduated prompts${NC}"
    echo -e "${YELLOW}• Start with simple prompts, escalate to 'think harder' only when needed${NC}"
  fi
  
  if [ "$large_files" -gt 3 ]; then
    echo -e "${YELLOW}• Large context detected - consider file splitting${NC}"
    echo -e "${YELLOW}• Use surgical fix templates for focused changes${NC}"
  fi
  
  echo -e "${GREEN}✓ Usage analysis completed${NC}"
}

# Function to auto-cleanup after commits
function auto_post_commit_cleanup() {
  echo -e "${BRIGHT_BLURPLE}🤖 Auto-cleanup after commit detected...${NC}"
  
  # Check if there are recent commits (last 10 minutes)
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local recent_commits=$(git log --since="10 minutes ago" --oneline 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$recent_commits" -gt 0 ]; then
      echo -e "${GREEN}✓ Recent commit detected, running comprehensive cleanup...${NC}"
      
      # Run full optimization
      optimize_context
      
      # Validate dependencies and documentation
      validate_action_completeness
      
      return 0
    fi
  fi
  
  return 1
}

# Function to validate action completeness and RULES compliance
function validate_action_completeness() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$current_action" = "None" ] || [ "$current_action" = "AICheckExec" ]; then
    return 0
  fi
  
  echo -e "\n${BRIGHT_BLURPLE}🔍 Validating RULES compliance and action completeness...${NC}"
  
  local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir=".aicheck/actions/$dir_name"
  local issues=()
  local auto_fixes=()
  
  # 1. RULES: Check action status and matrix updates
  echo -e "${BRIGHT_BLURPLE}📋 Checking action status compliance...${NC}"
  
  if [ ! -f "$action_dir/status.txt" ]; then
    issues+=("Action status file missing")
    auto_fixes+=("create_status_file")
  fi
  
  # Verify actions_index.md is current
  if [ -f ".aicheck/actions_index.md" ]; then
    if ! grep -q "$current_action" .aicheck/actions_index.md; then
      issues+=("Action not registered in actions_index.md")
      auto_fixes+=("update_actions_index")
    fi
  fi
  
  # 2. RULES: Check action timeline and progress tracking
  echo -e "${BRIGHT_BLURPLE}📈 Checking timeline and progress compliance...${NC}"
  
  if [ ! -f "$action_dir/progress.md" ]; then
    issues+=("Progress tracking missing: $action_dir/progress.md")
    auto_fixes+=("create_progress_tracking")
  else
    # Check if progress has been updated recently
    local last_update=$(stat -f "%m" "$action_dir/progress.md" 2>/dev/null || stat -c "%Y" "$action_dir/progress.md" 2>/dev/null || echo "0")
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_update))
    if [ "$time_diff" -gt 86400 ]; then  # 24 hours
      issues+=("Progress tracking not updated in 24+ hours")
      auto_fixes+=("update_progress_timestamp")
    fi
  fi
  
  # 3. RULES: Check dependency documentation
  echo -e "${BRIGHT_BLURPLE}🔗 Checking dependency compliance...${NC}"
  
  # Check for code dependencies that aren't documented
  if git status --porcelain 2>/dev/null | grep -q "package.json\|requirements.txt\|go.mod\|Cargo.toml\|pom.xml\|build.gradle"; then
    if ! grep -q "$current_action" documentation/dependencies/dependency_index.md 2>/dev/null; then
      issues+=("Dependencies modified but not documented for $current_action")
    fi
  fi
  
  # Check for import statements in modified files
  local modified_files=$(git status --porcelain 2>/dev/null | awk '{print $2}')
  local has_imports=false
  for file in $modified_files; do
    if [[ "$file" =~ \.(py|js|ts|jsx|tsx)$ ]] && [ -f "$file" ]; then
      if grep -q "^import\|^from.*import\|require(" "$file" 2>/dev/null; then
        has_imports=true
        break
      fi
    fi
  done
  
  if [ "$has_imports" = true ] && ! grep -q "$current_action" documentation/dependencies/dependency_index.md 2>/dev/null; then
    issues+=("Code imports detected but dependencies not documented")
  fi
  
  # 4. RULES: Check action plan compliance
  echo -e "${BRIGHT_BLURPLE}📝 Checking action plan compliance...${NC}"
  
  if [ ! -f "$action_dir/$dir_name-plan.md" ]; then
    issues+=("Action plan missing: $action_dir/$dir_name-plan.md")
    auto_fixes+=("create_action_plan")
  else
    # Check plan has required sections
    local plan_file="$action_dir/$dir_name-plan.md"
    if ! grep -q "## Purpose" "$plan_file"; then
      issues+=("Action plan missing Purpose section")
    fi
    if ! grep -q "## Requirements" "$plan_file"; then
      issues+=("Action plan missing Requirements section") 
    fi
    if ! grep -q "## Success Criteria" "$plan_file"; then
      issues+=("Action plan missing Success Criteria section")
    fi
    if ! grep -q "Progress:" "$plan_file"; then
      issues+=("Action plan missing Progress tracking")
      auto_fixes+=("add_progress_to_plan")
    fi
  fi
  
  # 5. RULES: Check Claude interaction logging
  echo -e "${BRIGHT_BLURPLE}💬 Checking Claude interaction compliance...${NC}"
  
  local interaction_dir="$action_dir/supporting_docs/claude-interactions"
  if [ ! -d "$interaction_dir" ] || [ $(find "$interaction_dir" -name "*.md" 2>/dev/null | wc -l) -eq 0 ]; then
    issues+=("No Claude interactions logged for $current_action")
    auto_fixes+=("create_interaction_structure")
  fi
  
  # 6. RULES: Check documentation migration for completed features
  if [ -f "$action_dir/status.txt" ] && grep -q "Completed" "$action_dir/status.txt"; then
    echo -e "${BRIGHT_BLURPLE}📚 Checking documentation migration for completed action...${NC}"
    
    # Check if documentation has been migrated to central docs
    if [ ! -f "documentation/api/actions-completed.md" ]; then
      auto_fixes+=("create_completed_docs")
    fi
  fi
  
  # 7. RULES: Check test compliance
  echo -e "${BRIGHT_BLURPLE}🧪 Checking test compliance...${NC}"
  
  # Look for implementation files without corresponding tests
  local impl_files=$(git status --porcelain 2>/dev/null | awk '{print $2}' | grep -E "\.(py|js|ts|jsx|tsx)$" | grep -v test | grep -v spec)
  if [ -n "$impl_files" ]; then
    local has_tests=false
    for file in $impl_files; do
      local test_file1="${file%.*}.test.${file##*.}"
      local test_file2="${file%.*}_test.${file##*.}"
      local test_file3="tests/$(basename "${file%.*}").test.${file##*.}"
      if [ -f "$test_file1" ] || [ -f "$test_file2" ] || [ -f "$test_file3" ]; then
        has_tests=true
        break
      fi
    done
    
    if [ "$has_tests" = false ]; then
      issues+=("Implementation files modified without corresponding tests")
    fi
  fi
  
  # Report issues and perform auto-fixes
  if [ ${#issues[@]} -gt 0 ]; then
    echo -e "${YELLOW}⚠ Found ${#issues[@]} RULES compliance issues:${NC}"
    printf '  - %s\n' "${issues[@]}"
    
    echo -e "\n${BRIGHT_BLURPLE}🔧 Auto-fixing compliance issues...${NC}"
    
    # Perform auto-fixes
    for fix in "${auto_fixes[@]}"; do
      case $fix in
        "create_status_file")
          echo "ActiveAction" > "$action_dir/status.txt"
          echo -e "${GREEN}✓ Created status file${NC}"
          ;;
        "create_progress_tracking")
          cat > "$action_dir/progress.md" << PROGRESS
# $current_action Progress

## Updates

$(date +"%Y-%m-%d") - Auto-created progress tracking for RULES compliance
$(date +"%Y-%m-%d") - Action status: $(cat "$action_dir/status.txt" 2>/dev/null || echo "ActiveAction")

## Timeline

- $(date +"%Y-%m-%d"): Action created/reactivated
- Next update: [Track your progress here]

## Tasks

- [ ] Update this file with your progress
- [ ] Document any dependencies added  
- [ ] Update action plan if scope changes
- [ ] Ensure tests are written before implementation
- [ ] Log Claude interactions as you work

## Dependencies Added

[Document any new dependencies here]

## Documentation Migration

[Track any documentation that needs to be moved to central docs]

PROGRESS
          echo -e "${GREEN}✓ Created RULES-compliant progress tracking${NC}"
          ;;
        "create_action_plan")
          cat > "$action_dir/$dir_name-plan.md" << PLAN
# ACTION: $current_action

Version: 1.0
Last Updated: $(date +"%Y-%m-%d")
Status: ActiveAction
Progress: 0%

## Purpose

[Describe the purpose of this ACTION and its value to the PROGRAM]

## Requirements

- [Requirement 1]
- [Requirement 2]

## Dependencies

- [Document any dependencies here]

## Implementation Approach

### Phase 1: Research and Planning
- [Research tasks]

### Phase 2: Test Design
- [Test specifications and cases]

### Phase 3: Implementation  
- [Implementation tasks]

### Phase 4: Documentation
- [Documentation and migration tasks]

## Success Criteria

- [Criterion 1: Tests pass]
- [Criterion 2: Documentation complete]
- [Criterion 3: Dependencies documented]

## Timeline

- Start: $(date +"%Y-%m-%d")
- Target completion: [Set target date]

PLAN
          echo -e "${GREEN}✓ Created RULES-compliant action plan${NC}"
          ;;
        "create_interaction_structure")
          mkdir -p "$interaction_dir"
          cat > "$interaction_dir/README.md" << INTERACTIONS
# Claude Interactions for $current_action

This directory contains all Claude Code interactions for this action.

## RULES Compliance

- All Claude interactions must be logged here
- Include purpose, date, and content for each interaction
- Interactions help track decision-making process
- Required for action completion verification

## File Naming

Use format: YYYY-MM-DD_HHMMSS-purpose.md

INTERACTIONS
          echo -e "${GREEN}✓ Created Claude interactions structure${NC}"
          ;;
        "update_actions_index")
          # Add action to index if not present
          if [ -f ".aicheck/actions_index.md" ]; then
            if ! grep -q "$current_action" .aicheck/actions_index.md; then
              local line_num=$(grep -n "| \*None yet\* |" .aicheck/actions_index.md | head -1 | cut -d':' -f1)
              if [ -n "$line_num" ]; then
                sed -i "" "${line_num}s/| \*None yet\* | | | | |/| $current_action | | ActiveAction | 0% | |\\n| \*None yet\* | | | | |/" .aicheck/actions_index.md
                echo -e "${GREEN}✓ Updated actions index${NC}"
              fi
            fi
          fi
          ;;
        "add_progress_to_plan")
          if [ -f "$action_dir/$dir_name-plan.md" ] && ! grep -q "Progress:" "$action_dir/$dir_name-plan.md"; then
            sed -i "" '/^Status:/a\
Progress: 0%' "$action_dir/$dir_name-plan.md"
            echo -e "${GREEN}✓ Added progress tracking to plan${NC}"
          fi
          ;;
        "update_progress_timestamp")
          echo "$(date +"%Y-%m-%d") - Progress check during cleanup validation" >> "$action_dir/progress.md"
          echo -e "${GREEN}✓ Updated progress timestamp${NC}"
          ;;
        "create_completed_docs")
          mkdir -p documentation/api
          if [ ! -f "documentation/api/actions-completed.md" ]; then
            cat > "documentation/api/actions-completed.md" << COMPLETED
# Completed Actions Documentation

This file tracks completed actions and their documentation migration.

## Completed Actions

### $current_action
- Completion Date: $(date +"%Y-%m-%d")
- Documentation Location: [Link to migrated docs]
- Key Deliverables: [List main outputs]

COMPLETED
            echo -e "${GREEN}✓ Created completed actions documentation${NC}"
          fi
          ;;
      esac
    done
    
    # Update actions index timestamp
    if [ -f ".aicheck/actions_index.md" ]; then
      sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
    fi
    
    echo -e "${YELLOW}Manual fixes still needed:${NC}"
    echo -e "${YELLOW}• Document dependencies: ./aicheck dependency add NAME VERSION JUSTIFICATION${NC}"
    echo -e "${YELLOW}• Write tests before implementation (RULES requirement)${NC}"
    echo -e "${YELLOW}• Log Claude interactions during work${NC}"
    echo -e "${YELLOW}• Update action plan with specific requirements${NC}"
    echo -e "${YELLOW}• Migrate documentation to central folders when action completes${NC}"
  else
    echo -e "${GREEN}✓ Full RULES compliance verified${NC}"
  fi
}

# Function to optimize context for cost efficiency
function optimize_context() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Context Optimization${NC}"
  echo -e "Optimizing for cost efficiency and performance..."
  
  # Automated optimization (no approval needed)
  echo -e "\n${BRIGHT_BLURPLE}Performing automated optimizations...${NC}"
  
  # Compress old interaction logs
  if [ -d ".aicheck" ]; then
    find .aicheck -name "claude-interactions" -type d | while read dir; do
      if [ $(find "$dir" -name "*.md" 2>/dev/null | wc -l) -gt 10 ]; then
        mkdir -p "$dir/compressed"
        # Move old interactions to compressed folder
        find "$dir" -name "*.md" -mtime +7 | head -n -5 | while read file; do
          mv "$file" "$dir/compressed/" 2>/dev/null || true
        done
      fi
    done
    echo -e "${GREEN}✓ Compressed old interaction logs${NC}"
  fi
  
  # Generate context summary for large files
  local summary_file=".aicheck/context-summary-$(date +%Y%m%d).md"
  cat > "$summary_file" << SUMMARY
# Context Summary - $(date)

## Project Overview
$(head -20 README.md 2>/dev/null || echo "No README found")

## Current Action
$(cat .aicheck/current_action 2>/dev/null || echo "None")

## Active Files (Modified in last 7 days)
$(find . -name "*.js" -o -name "*.py" -o -name "*.ts" -o -name "*.md" -mtime -7 2>/dev/null | head -20)

## Key Dependencies
$(if [ -f "package.json" ]; then jq -r '.dependencies | keys[]' package.json 2>/dev/null | head -10; fi)
$(if [ -f "requirements.txt" ]; then head -10 requirements.txt 2>/dev/null; fi)

## Recent Changes
$(git log --oneline -10 2>/dev/null || echo "No git history")

*This summary can be used instead of reading many individual files to understand project context*
SUMMARY
  
  echo -e "${GREEN}✓ Generated context summary: $(basename "$summary_file")${NC}"
  
  # Cache frequently accessed patterns
  local cache_file=".aicheck/pattern-cache-$(date +%Y%m%d).md"
  cat > "$cache_file" << CACHE
# Frequently Used Patterns Cache

## Code Patterns
$(grep -r "function\|class\|const\|def " --include="*.js" --include="*.py" --include="*.ts" . 2>/dev/null | head -20)

## Import Patterns  
$(grep -r "import\|require\|from " --include="*.js" --include="*.py" --include="*.ts" . 2>/dev/null | head -15)

## Test Patterns
$(find . -name "*test*" -o -name "*spec*" -name "*.js" -o -name "*.py" -o -name "*.ts" 2>/dev/null | head -10)

*Cache generated: $(date)*
CACHE
  
  echo -e "${GREEN}✓ Cached common patterns for quick reference${NC}"
  
  # Analyze context efficiency
  local total_size=$(du -sh . 2>/dev/null | cut -f1)
  local aicheck_size=$(du -sh .aicheck 2>/dev/null | cut -f1)
  
  echo -e "\n${BRIGHT_BLURPLE}Context Efficiency Report:${NC}"
  echo -e "Total project size: ${GREEN}$total_size${NC}"
  echo -e "AICheck overhead: ${GREEN}$aicheck_size${NC}"
  echo -e "Optimization files created: ${GREEN}2${NC}"
  
  echo -e "\n${GREEN}✓ Context optimization completed${NC}"
  echo -e "${BRIGHT_BLURPLE}Use context summary and pattern cache for efficient prompting${NC}"
}

# Function to automatically enforce action boundaries
function enforce_action_boundaries() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$current_action" = "None" ] || [ "$current_action" = "AICheckExec" ]; then
    echo -e "${YELLOW}No active action - boundary enforcement skipped${NC}"
    return 0
  fi
  
  echo -e "${BRIGHT_BLURPLE}Enforcing boundaries for: ${GREEN}$current_action${NC}"
  
  local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir=".aicheck/actions/$dir_name"
  
  # Check for scope creep indicators
  local scope_warnings=()
  
  # Check if working outside action directory
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    local changed_files=$(git status --porcelain 2>/dev/null | awk '{print $2}')
    local outside_scope=0
    
    for file in $changed_files; do
      # Skip if file is in action directory or common project files
      if [[ ! "$file" =~ ^\.aicheck/actions/$dir_name/ ]] && 
         [[ ! "$file" =~ ^(src/|tests/|documentation/|README|\.md$) ]]; then
        outside_scope=$((outside_scope + 1))
      fi
    done
    
    if [ "$outside_scope" -gt 0 ]; then
      scope_warnings+=("$outside_scope files modified outside expected scope")
    fi
  fi
  
  # Check for excessive new dependencies
  if [ -f "documentation/dependencies/dependency_index.md" ]; then
    local recent_deps=$(grep "$(date +"%Y-%m-%d")" documentation/dependencies/dependency_index.md | grep "$current_action" | wc -l | tr -d ' ')
    if [ "$recent_deps" -gt 3 ]; then
      scope_warnings+=("$recent_deps new dependencies added today")
    fi
  fi
  
  # Check for multiple action modifications
  local modified_actions=$(find .aicheck/actions -name "*.md" -newer .aicheck/current_action 2>/dev/null | grep -v "$dir_name" | wc -l | tr -d ' ')
  if [ "$modified_actions" -gt 0 ]; then
    scope_warnings+=("$modified_actions other actions modified during this session")
  fi
  
  if [ ${#scope_warnings[@]} -gt 0 ]; then
    echo -e "${YELLOW}⚠ Potential scope creep detected:${NC}"
    printf '  - %s\n' "${scope_warnings[@]}"
    echo -e "${YELLOW}Consider using './aicheck context clear' if work has drifted${NC}"
    return 1
  else
    echo -e "${GREEN}✓ Action boundaries maintained${NC}"
    return 0
  fi
}

# Function to detect if this is a new session and auto-run stuck command
function auto_session_start_check() {
  # Check if this appears to be a new session by looking for recent activity
  local session_marker=".aicheck/last_session_timestamp"
  local current_time=$(date +%s)
  local session_gap=3600  # 1 hour gap indicates new session
  
  # Create .aicheck directory if it doesn't exist
  mkdir -p .aicheck
  
  # Check if we have a previous session timestamp
  if [ -f "$session_marker" ]; then
    local last_session=$(cat "$session_marker" 2>/dev/null || echo "0")
    local time_diff=$((current_time - last_session))
    
    if [ "$time_diff" -gt "$session_gap" ]; then
      echo -e "${BRIGHT_BLURPLE}🆕 New session detected (${time_diff}s gap)${NC}"
      echo -e "${BRIGHT_BLURPLE}🤖 Auto-running session startup checks...${NC}"
      
      # Update session timestamp
      echo "$current_time" > "$session_marker"
      
      # Run stuck command logic without the full UI (simplified for robustness)
      echo -e "${YELLOW}Session Summary:${NC}"
      local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      echo -e "Current Action: ${GREEN}$current_action${NC}"
      
      # Check for basic issues (simplified)
      local pollution_score=0
      if [ -d ".aicheck/actions" ]; then
        local active_count=$(find .aicheck/actions -name "status.txt" -exec grep -l "ActiveAction" {} \; 2>/dev/null | wc -l | tr -d ' ')
        if [ "$active_count" -gt 1 ]; then
          pollution_score=30
        fi
      fi
      
      if [ "$pollution_score" -gt 30 ]; then
        echo -e "${YELLOW}⚠ Context pollution detected${NC}"
        echo -e "${YELLOW}Consider running './aicheck cleanup' before starting work${NC}"
      fi
      
      echo -e "${GREEN}✓ Session startup complete${NC}"
      return 0
    fi
  fi
  
  # Update session timestamp for normal commands
  echo "$current_time" > "$session_marker"
  return 1
}

# Function to auto-run focus check before new actions
function auto_focus_check() {
  echo -e "${BRIGHT_BLURPLE}🤖 Auto-checking focus before creating new action...${NC}"
  
  # Check if there's an active action
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    echo -e "${YELLOW}⚠ You have an active action: $current_action${NC}"
    
    # Auto-check boundaries
    if ! enforce_action_boundaries >/dev/null 2>&1; then
      echo -e "${YELLOW}🎯 Scope creep detected in current action!${NC}"
      echo -e "${YELLOW}Consider completing '$current_action' first or running './aicheck focus' for details${NC}"
      echo -e "${YELLOW}Continue creating new action anyway? (y/n)${NC}"
      read -r continue_anyway
      
      if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
        echo -e "${YELLOW}Action creation cancelled. Fix current action first.${NC}"
        return 1
      fi
    else
      echo -e "${GREEN}✓ Current action boundaries look good${NC}"
    fi
  fi
  
  # Check context pollution
  local pollution_data=$(detect_context_pollution)
  local pollution_score=$(echo "$pollution_data" | head -1)
  
  if [ "$pollution_score" -gt 30 ]; then
    echo -e "${YELLOW}⚠ Context pollution detected (score: $pollution_score)${NC}"
    echo -e "${YELLOW}Recommend running './aicheck cleanup' before starting new work${NC}"
    echo -e "${YELLOW}Continue anyway? (y/n)${NC}"
    read -r continue_anyway
    
    if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
      echo -e "${YELLOW}Action creation cancelled. Clean up context first.${NC}"
      return 1
    fi
  fi
  
  echo -e "${GREEN}✓ Focus check passed${NC}"
  return 0
}

# Function to create a new action
function create_action() {
  local action_name=$1
  
  if [ -z "$action_name" ]; then
    echo -e "${RED}Error: Action name is required${NC}"
    echo "Usage: ./aicheck action new ACTION_NAME"
    exit 1
  fi
  
  # Auto-run focus check before creating action
  if ! auto_focus_check; then
    return 1
  fi
  
  # Convert PascalCase to kebab-case for directories (compatible with macOS)
  local dir_name=$(echo "$action_name" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  # Create action directory
  mkdir -p ".aicheck/actions/$dir_name"
  mkdir -p ".aicheck/actions/$dir_name/supporting_docs/claude-interactions"
  mkdir -p ".aicheck/actions/$dir_name/supporting_docs/process-tests"
  mkdir -p ".aicheck/actions/$dir_name/supporting_docs/research"
  
  # Create plan file
  cat > ".aicheck/actions/$dir_name/$dir_name-plan.md" << PLAN
# ACTION: $action_name

Version: 1.0
Last Updated: $(date +"%Y-%m-%d")
Status: Not Started
Progress: 0%

## Purpose

[Describe the purpose of this ACTION and its value to the PROGRAM]

## Requirements

- [Requirement 1]
- [Requirement 2]

## Dependencies

- [Dependency 1, if any]

## Implementation Approach

### Phase 1: Research

- [Research task 1]
- [Research task 2]

### Phase 2: Design

- [Design task 1]
- [Design task 2]

### Phase 3: Implementation

- [Implementation task 1]
- [Implementation task 2]

### Phase 4: Testing

- [Test case 1]
- [Test case 2]

## Success Criteria

- [Criterion 1]
- [Criterion 2]

## Estimated Timeline

- Research: [X days]
- Design: [X days]
- Implementation: [X days]
- Testing: [X days]
- Total: [X days]

## Notes

[Any additional notes or considerations]
PLAN
  
  # Create status file
  echo "Not Started" > ".aicheck/actions/$dir_name/status.txt"
  
  # Create progress file
  echo "# $action_name Progress

## Updates

$(date +"%Y-%m-%d") - Action created

## Tasks

- [ ] Research phase
- [ ] Design phase
- [ ] Implementation phase
- [ ] Testing phase
- [ ] Documentation
" > ".aicheck/actions/$dir_name/progress.md"
  
  # Update actions_index.md
  # Get the line number of the "Active Actions" table's end
  line_num=$(grep -n "\| \*None yet\* \| \| \| \| \|" .aicheck/actions_index.md | cut -d':' -f1)
  
  if [ -n "$line_num" ]; then
    # Replace the "None yet" line with the new action
    sed -i "" "$line_num s/| \*None yet\* | | | | |/| $action_name | | Not Started | 0% | |\n| \*None yet\* | | | | |/" .aicheck/actions_index.md
  else
    # Append to the Active Actions table
    line_num=$(grep -n "## Active Actions" .aicheck/actions_index.md | cut -d':' -f1)
    if [ -n "$line_num" ]; then
      awk -v line="$line_num" -v action="| $action_name | | Not Started | 0% | |" 'NR==line+4{print action}1' .aicheck/actions_index.md > .aicheck/actions_index.md.tmp
      mv .aicheck/actions_index.md.tmp .aicheck/actions_index.md
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  
  echo -e "${GREEN}✓ Created new ACTION: $action_name${NC}"
  echo -e "${BRIGHT_BLURPLE}Directory: .aicheck/actions/$dir_name${NC}"
  echo -e "${YELLOW}NOTE: This ACTION requires planning and approval before implementation${NC}"
}

# Function to set the active action
function set_active_action() {
  local action_name=$1
  
  if [ -z "$action_name" ]; then
    echo -e "${RED}Error: Action name is required${NC}"
    echo "Usage: ./aicheck action set ACTION_NAME"
    exit 1
  fi
  
  # Convert PascalCase to kebab-case for directories (compatible with macOS)
  local dir_name=$(echo "$action_name" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  # Check if action exists
  if [ ! -d ".aicheck/actions/$dir_name" ]; then
    echo -e "${RED}Error: Action '$action_name' does not exist${NC}"
    echo "Available actions:"
    ls -1 .aicheck/actions/ | grep -v "README"
    exit 1
  fi
  
  # Set as current action
  echo "$action_name" > .aicheck/current_action
  
  # Update status to ActiveAction if not already
  if [ "$(cat ".aicheck/actions/$dir_name/status.txt")" != "ActiveAction" ]; then
    echo "ActiveAction" > ".aicheck/actions/$dir_name/status.txt"
    
    # Update actions_index.md
    sed -i "" "s/| $action_name | .* | [^|]* | [^|]* | /| $action_name | | ActiveAction | 0% | /" .aicheck/actions_index.md
    
    # Update last updated date
    sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  fi
  
  echo -e "${GREEN}✓ Set current action to: $action_name${NC}"
}

# Function to complete an action
function complete_action() {
  local action_name=$1
  
  # If no action name is provided, use the current action
  if [ -z "$action_name" ]; then
    if [ -f ".aicheck/current_action" ]; then
      action_name=$(cat .aicheck/current_action)
    fi
  fi
  
  if [ -z "$action_name" ] || [ "$action_name" = "None" ] || [ "$action_name" = "AICheckExec" ]; then
    echo -e "${RED}Error: No action specified and no current action set${NC}"
    echo "Usage: ./aicheck action complete [ACTION_NAME]"
    exit 1
  fi
  
  # Convert PascalCase to kebab-case for directories (compatible with macOS)
  local dir_name=$(echo "$action_name" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  # Check if action exists
  if [ ! -d ".aicheck/actions/$dir_name" ]; then
    echo -e "${RED}Error: Action '$action_name' does not exist${NC}"
    echo "Available actions:"
    ls -1 .aicheck/actions/ | grep -v "README"
    exit 1
  fi
  
  # Verify dependencies
  echo -e "${BRIGHT_BLURPLE}Verifying dependencies for $action_name...${NC}"
  
  local has_dependencies=0
  if [ -f "documentation/dependencies/dependency_index.md" ]; then
    # Check for dependencies in the dependency index
    if grep -q "$action_name" documentation/dependencies/dependency_index.md; then
      has_dependencies=1
      echo -e "${GREEN}✓ Dependencies documented for $action_name${NC}"
      
      # Display documented dependencies
      echo -e "${BRIGHT_BLURPLE}Dependencies documented:${NC}"
      grep -A 1 -B 1 "$action_name" documentation/dependencies/dependency_index.md
    fi
  fi
  
  # Check for imports in code files
  local imports_found=0
  local deps_dir=".aicheck/actions/$dir_name"
  
  if [ -d "$deps_dir" ]; then
    # Look for Python imports
    if find "$deps_dir" -type f -name "*.py" | xargs grep -l "^import\|^from .* import" 2>/dev/null; then
      imports_found=1
    fi
    
    # Look for JS/TS imports
    if find "$deps_dir" -type f -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" | xargs grep -l "^import\|require(" 2>/dev/null; then
      imports_found=1
    fi
  fi
  
  if [ $imports_found -eq 1 ] && [ $has_dependencies -eq 0 ]; then
    echo -e "${YELLOW}WARNING: Code imports found but no dependencies documented.${NC}"
    echo -e "${YELLOW}Please document dependencies with:${NC}"
    echo -e "${YELLOW}./aicheck dependency add NAME VERSION JUSTIFICATION $action_name${NC}"
    echo -e "${YELLOW}Continue anyway? (y/n)${NC}"
    read -r continue_anyway
    
    if [[ $continue_anyway != "y" && $continue_anyway != "Y" ]]; then
      echo -e "${YELLOW}Action completion aborted. Please document dependencies first.${NC}"
      exit 0
    fi
  fi
  
  # Update action status
  echo "Completed" > ".aicheck/actions/$dir_name/status.txt"
  
  # Update progress to 100%
  sed -i "" "s/Progress: .*%/Progress: 100%/" ".aicheck/actions/$dir_name/$dir_name-plan.md"
  
  # Update actions_index.md
  # First, remove from Active Actions
  sed -i "" "/| $action_name | .* | [^|]* | [^|]* | .*|/d" .aicheck/actions_index.md
  
  # Then, add to Completed Actions
  # Get the line number of the "Completed Actions" table's end
  line_num=$(grep -n "\| \*None yet\* \| \| \| \|" .aicheck/actions_index.md | sed -n '2p' | cut -d':' -f1)
  
  if [ -n "$line_num" ]; then
    # Replace the "None yet" line with the new action
    sed -i "" "$line_num s/| \*None yet\* | | | |/| $action_name | | $(date +"%Y-%m-%d") | |\n| \*None yet\* | | | |/" .aicheck/actions_index.md
  else
    # Append to the Completed Actions table
    line_num=$(grep -n "## Completed Actions" .aicheck/actions_index.md | cut -d':' -f1)
    if [ -n "$line_num" ]; then
      awk -v line="$line_num" -v action="| $action_name | | $(date +"%Y-%m-%d") | |" 'NR==line+4{print action}1' .aicheck/actions_index.md > .aicheck/actions_index.md.tmp
      mv .aicheck/actions_index.md.tmp .aicheck/actions_index.md
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" .aicheck/actions_index.md
  
  # If this was the current action, set current action to None
  if [ -f ".aicheck/current_action" ] && [ "$(cat .aicheck/current_action)" = "$action_name" ]; then
    echo "None" > .aicheck/current_action
    echo -e "${BRIGHT_BLURPLE}Current action reset to None${NC}"
  fi
  
  echo -e "${GREEN}✓ Completed ACTION: $action_name${NC}"
  echo -e "${BRIGHT_BLURPLE}Updated status, progress, and actions index${NC}"
}

# Function to toggle exec mode
function exec_mode() {
  # Save current action
  local current_action=$(cat .aicheck/current_action)
  
  if [ "$current_action" = "AICheckExec" ]; then
    # Exit exec mode, return to previous action
    if [ -f .aicheck/previous_action ]; then
      local previous_action=$(cat .aicheck/previous_action)
      echo "$previous_action" > .aicheck/current_action
      rm .aicheck/previous_action
      echo -e "${GREEN}✓ Exited Exec Mode${NC}"
      echo -e "${BRIGHT_BLURPLE}Returned to action: $previous_action${NC}"
    else
      echo "None" > .aicheck/current_action
      echo -e "${GREEN}✓ Exited Exec Mode${NC}"
      echo -e "${BRIGHT_BLURPLE}No previous action found${NC}"
    fi
  else
    # Enter exec mode, save current action
    echo "$current_action" > .aicheck/previous_action
    echo "AICheckExec" > .aicheck/current_action
    echo -e "${GREEN}✓ Entered AICheck Exec Mode${NC}"
    echo -e "${YELLOW}NOTE: Exec Mode is for system maintenance only${NC}"
    echo -e "${YELLOW}No substantive code changes should be made in this mode${NC}"
  fi
}

# Function to add an external dependency
function add_dependency() {
  local name=$1
  local version=$2
  local justification=$3
  local action=$4
  
  if [ -z "$name" ] || [ -z "$version" ] || [ -z "$justification" ]; then
    echo -e "${RED}Error: Missing required arguments${NC}"
    echo "Usage: ./aicheck dependency add NAME VERSION JUSTIFICATION [ACTION]"
    exit 1
  fi
  
  # If no action is provided, use the current action
  if [ -z "$action" ]; then
    if [ -f ".aicheck/current_action" ]; then
      action=$(cat .aicheck/current_action)
    fi
  fi
  
  if [ -z "$action" ] || [ "$action" = "None" ] || [ "$action" = "AICheckExec" ]; then
    echo -e "${YELLOW}Warning: No action specified or current action set.${NC}"
    echo -e "${YELLOW}Dependency will be added without associating with an action.${NC}"
    action=""
  fi
  
  # Create dependency index if it doesn't exist
  mkdir -p documentation/dependencies
  if [ ! -f "documentation/dependencies/dependency_index.md" ]; then
    cat > documentation/dependencies/dependency_index.md << 'EODOC'
# Dependency Index

This document tracks all dependencies in the PROJECT. All dependencies must be registered here.

## External Dependencies

| Dependency | Version | Added By | Date Added | Justification | Actions Using |
|------------|---------|----------|------------|---------------|---------------|
| *None yet* | | | | | |

## Internal Dependencies

| Dependency Action | Dependent Action | Type | Date Added | Description |
|-------------------|------------------|------|------------|-------------|
| *None yet* | | | | |

---
*Last Updated: $(date +"%Y-%m-%d")*
EODOC
  fi
  
  # Check if dependency already exists
  if grep -q "| $name | $version |" documentation/dependencies/dependency_index.md; then
    echo -e "${YELLOW}Dependency $name@$version already exists.${NC}"
    echo -e "${YELLOW}Updating to add this action as a user.${NC}"
    
    # Extract existing actions using this dependency
    local existing_actions=$(grep "| $name | $version |" documentation/dependencies/dependency_index.md | awk -F '|' '{print $6}' | xargs)
    
    # Add the current action if not already included
    if [ -n "$action" ] && ! echo "$existing_actions" | grep -q "$action"; then
      local new_actions="$existing_actions, $action"
      # Update the dependency entry
      sed -i "" "s/| $name | $version |.*|.*|.*|.*|/| $name | $version | | $(date +"%Y-%m-%d") | $justification | $new_actions |/" documentation/dependencies/dependency_index.md
    fi
  else
    # Get the line number of the "External Dependencies" table's "None yet" row
    line_num=$(grep -n "\| \*None yet\* \| \| \| \| \| \|" documentation/dependencies/dependency_index.md | cut -d':' -f1)
    
    if [ -n "$line_num" ]; then
      # Replace the "None yet" line with the new dependency
      sed -i "" "$line_num s/| \*None yet\* | | | | | |/| $name | $version | | $(date +"%Y-%m-%d") | $justification | $action |\n| \*None yet\* | | | | | |/" documentation/dependencies/dependency_index.md
    else
      # Append to the External Dependencies table
      line_num=$(grep -n "## External Dependencies" documentation/dependencies/dependency_index.md | cut -d':' -f1)
      if [ -n "$line_num" ]; then
        let line_num+=4  # Move to after the header row
        awk -v line="$line_num" -v dep="| $name | $version | | $(date +"%Y-%m-%d") | $justification | $action |" 'NR==line{print dep}1' documentation/dependencies/dependency_index.md > documentation/dependencies/dependency_index.md.tmp
        mv documentation/dependencies/dependency_index.md.tmp documentation/dependencies/dependency_index.md
      fi
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" documentation/dependencies/dependency_index.md
  
  echo -e "${GREEN}✓ Added external dependency: $name@$version${NC}"
  if [ -n "$action" ]; then
    echo -e "${BRIGHT_BLURPLE}Associated with action: $action${NC}"
  fi
}

# Function to add an internal dependency
function add_internal_dependency() {
  local dep_action=$1
  local action=$2
  local type=$3
  local description=$4
  
  if [ -z "$dep_action" ] || [ -z "$action" ] || [ -z "$type" ]; then
    echo -e "${RED}Error: Missing required arguments${NC}"
    echo "Usage: ./aicheck dependency internal DEP_ACTION ACTION TYPE [DESCRIPTION]"
    exit 1
  fi
  
  # Create dependency index if it doesn't exist
  mkdir -p documentation/dependencies
  if [ ! -f "documentation/dependencies/dependency_index.md" ]; then
    cat > documentation/dependencies/dependency_index.md << 'EODOC2'
# Dependency Index

This document tracks all dependencies in the PROJECT. All dependencies must be registered here.

## External Dependencies

| Dependency | Version | Added By | Date Added | Justification | Actions Using |
|------------|---------|----------|------------|---------------|---------------|
| *None yet* | | | | | |

## Internal Dependencies

| Dependency Action | Dependent Action | Type | Date Added | Description |
|-------------------|------------------|------|------------|-------------|
| *None yet* | | | | |

---
*Last Updated: $(date +"%Y-%m-%d")*
EODOC2
  fi
  
  # Check if both actions exist
  local dep_dir_name=$(echo "$dep_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  local action_dir_name=$(echo "$action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
  
  if [ ! -d ".aicheck/actions/$dep_dir_name" ]; then
    echo -e "${YELLOW}Warning: Dependency action '$dep_action' does not exist.${NC}"
  fi
  
  if [ ! -d ".aicheck/actions/$action_dir_name" ]; then
    echo -e "${YELLOW}Warning: Dependent action '$action' does not exist.${NC}"
  fi
  
  # Get the line number of the "Internal Dependencies" table's "None yet" row
  line_num=$(grep -n "\| \*None yet\* \| \| \| \| \|" documentation/dependencies/dependency_index.md | sed -n '2p' | cut -d':' -f1)
  
  if [ -n "$line_num" ]; then
    # Replace the "None yet" line with the new dependency
    sed -i "" "$line_num s/| \*None yet\* | | | | |/| $dep_action | $action | $type | $(date +"%Y-%m-%d") | ${description:-\"\"} |\n| \*None yet\* | | | | |/" documentation/dependencies/dependency_index.md
  else
    # Append to the Internal Dependencies table
    line_num=$(grep -n "## Internal Dependencies" documentation/dependencies/dependency_index.md | cut -d':' -f1)
    if [ -n "$line_num" ]; then
      let line_num+=4  # Move to after the header row
      awk -v line="$line_num" -v dep="| $dep_action | $action | $type | $(date +"%Y-%m-%d") | ${description:-\"\"} |" 'NR==line{print dep}1' documentation/dependencies/dependency_index.md > documentation/dependencies/dependency_index.md.tmp
      mv documentation/dependencies/dependency_index.md.tmp documentation/dependencies/dependency_index.md
    fi
  fi
  
  # Update last updated date
  sed -i "" "s/\*Last Updated: .*\*/\*Last Updated: $(date +"%Y-%m-%d")\*/" documentation/dependencies/dependency_index.md
  
  echo -e "${GREEN}✓ Added internal dependency${NC}"
  echo -e "${BRIGHT_BLURPLE}$action depends on $dep_action ($type)${NC}"
}

# Function to show the current status
function show_status() {
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  echo -e "${BRIGHT_BLURPLE}AICheck Status${NC}"
  echo -e "-------------------"
  echo -e "Current Action: ${GREEN}$current_action${NC}"
  
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    # Convert PascalCase to kebab-case for directories
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    
    if [ -d ".aicheck/actions/$dir_name" ]; then
      local status=$(cat ".aicheck/actions/$dir_name/status.txt" 2>/dev/null || echo "Unknown")
      local progress=$(grep "Progress:" ".aicheck/actions/$dir_name/$dir_name-plan.md" 2>/dev/null | cut -d':' -f2 | tr -d ' %' || echo "0")
      
      echo -e "Status: ${GREEN}$status${NC}"
      echo -e "Progress: ${GREEN}$progress%${NC}"
      echo -e "Plan: ${BRIGHT_BLURPLE}.aicheck/actions/$dir_name/$dir_name-plan.md${NC}"
      
      # Show dependencies
      if [ -f "documentation/dependencies/dependency_index.md" ]; then
        local deps=$(grep -c "$current_action" documentation/dependencies/dependency_index.md || echo "0")
        if [ "$deps" -gt "0" ]; then
          echo -e "\nDependencies for $current_action:"
          grep "$current_action" documentation/dependencies/dependency_index.md
        fi
      fi
    else
      echo -e "${YELLOW}Warning: Action directory not found for $current_action${NC}"
    fi
  elif [ "$current_action" = "AICheckExec" ]; then
    echo -e "${YELLOW}SYSTEM IS IN EXEC MODE${NC}"
    echo -e "${YELLOW}For system maintenance only${NC}"
    if [ -f .aicheck/previous_action ]; then
      local previous_action=$(cat .aicheck/previous_action)
      echo -e "Previous action: ${BRIGHT_BLURPLE}$previous_action${NC} (will be restored on exec mode exit)"
    fi
  fi
  
  # Show active actions
  echo -e "\nActive Actions:"
  if [ -f ".aicheck/actions_index.md" ]; then
    grep -A 5 "## Active Actions" .aicheck/actions_index.md | tail -n +4 | grep -v "\*None yet\*" | grep -v "^$" || echo "No active actions"
  else
    echo "No action index found"
  fi
  
  # Show context pollution analysis
  echo -e "\nContext Health:"
  pollution_data=$(detect_context_pollution)
  pollution_score=$(echo "$pollution_data" | head -1)
  warnings=$(echo "$pollution_data" | tail -n +2)
  
  if [ "$pollution_score" -le 20 ]; then
    echo -e "Pollution score: ${GREEN}$pollution_score/100 (Clean)${NC}"
  elif [ "$pollution_score" -le 50 ]; then
    echo -e "Pollution score: ${YELLOW}$pollution_score/100 (Moderate)${NC}"
  else
    echo -e "Pollution score: ${RED}$pollution_score/100 (High)${NC}"
    echo -e "${YELLOW}Consider running './aicheck context clear'${NC}"
  fi
  
  if [ -n "$warnings" ] && [ "$warnings" != "WARNINGS:" ]; then
    echo -e "${YELLOW}$warnings${NC}"
  fi
  
  # Show git status if in a git repo
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo -e "\nGit Status:"
    echo -e "Branch: $(git branch --show-current 2>/dev/null)"
    echo -e "Changes: $(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
    echo -e "Last commit: $(git log -1 --oneline 2>/dev/null || echo "No commits yet")"
  fi
  
  # Automatically check boundaries if there's an active action
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    echo -e "\nBoundary Check:"
    if enforce_action_boundaries >/dev/null 2>&1; then
      echo -e "${GREEN}✓ Action boundaries maintained${NC}"
    else
      echo -e "${YELLOW}⚠ Potential scope creep detected - run './aicheck context check' for details${NC}"
    fi
  fi
}

# Guardian System Functions
function handle_guardian() {
  local GUARDIAN_DIR=".aicheck/guardian"
  local GUARDIAN_DB="$GUARDIAN_DIR/guardian.db"
  local GUARDIAN_LOG="$GUARDIAN_DIR/guardian.log"
  local PROTECTED_FILES="$GUARDIAN_DIR/protected_files.txt"
  local HASHES_DB="$GUARDIAN_DIR/file_hashes.db"
  
  local subcmd="$1"
  shift
  
  case "$subcmd" in
    "init")
      mkdir -p "$GUARDIAN_DIR"
      touch "$GUARDIAN_DB" "$GUARDIAN_LOG" "$PROTECTED_FILES" "$HASHES_DB"
      echo -e "${BLUE}🛡️  AICheck Guardian Initialized${NC}"
      echo -e "${YELLOW}Use './aicheck guardian protect <file> <CRITICAL|SENSITIVE|MONITORED>' to protect files${NC}"
      ;;
    "protect")
      local file="$1"
      local level="${2:-MONITORED}"
      if [ ! -f "$file" ]; then
        echo -e "${RED}✗ File not found: $file${NC}"
        return 1
      fi
      local hash=$(shasum -a 256 "$file" | cut -d' ' -f1)
      echo "$file|$level|$hash|$(date +%s)" >> "$PROTECTED_FILES"
      echo "$file:$hash:$(date +%s)" >> "$HASHES_DB"
      echo "[$(date '+%Y-%m-%d %H:%M:%S')] PROTECT | $file | Added to $level protection | User: $(whoami)" >> "$GUARDIAN_LOG"
      echo -e "${GREEN}✓ Protected: $file (Level: $level)${NC}"
      ;;
    "check"|"scan")
      echo -e "${BLUE}🔍 Scanning protected files...${NC}"
      local violations=0
      while IFS='|' read -r file level hash timestamp; do
        if [ -n "$file" ] && [ -f "$file" ]; then
          local stored_hash=$(grep "^$file:" "$HASHES_DB" 2>/dev/null | cut -d':' -f2 | tail -1)
          local current_hash=$(shasum -a 256 "$file" 2>/dev/null | cut -d' ' -f1)
          if [ "$stored_hash" != "$current_hash" ]; then
            echo -e "${RED}🚨 INTEGRITY VIOLATION: $file has been modified!${NC}"
            if [ "$level" = "CRITICAL" ]; then
              echo -e "${RED}CRITICAL FILE MODIFIED - IMMEDIATE ACTION REQUIRED${NC}"
            fi
            ((violations++))
          else
            echo -e "${GREEN}✓ Integrity verified: $file${NC}"
          fi
        fi
      done < "$PROTECTED_FILES"
      if [ $violations -eq 0 ]; then
        echo -e "${GREEN}✅ All protected files intact${NC}"
      else
        echo -e "${RED}⚠️  Found $violations integrity violations${NC}"
      fi
      ;;
    "status")
      echo -e "${PURPLE}🛡️  AICheck Guardian Status${NC}"
      echo "========================="
      if [ -f "$PROTECTED_FILES" ]; then
        local total=$(wc -l < "$PROTECTED_FILES")
        local critical=$(grep "|CRITICAL|" "$PROTECTED_FILES" 2>/dev/null | wc -l)
        local sensitive=$(grep "|SENSITIVE|" "$PROTECTED_FILES" 2>/dev/null | wc -l)
        echo -e "Protected Files: ${BLUE}$total${NC}"
        echo -e "  ${RED}CRITICAL: $critical${NC}"
        echo -e "  ${YELLOW}SENSITIVE: $sensitive${NC}"
      else
        echo -e "${YELLOW}No files protected yet${NC}"
      fi
      
      # Check for blueprints
      if [ -f "$GUARDIAN_DIR/blueprints.json" ]; then
        local blueprint_count=$(grep -c "entry_point" "$GUARDIAN_DIR/blueprints.json" 2>/dev/null || echo "0")
        echo -e "\nCritical Paths: ${BLUE}$blueprint_count${NC}"
      fi
      
      # Integration with AICheck
      local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      if [ "$current_action" != "None" ]; then
        echo -e "\nActive Action: ${GREEN}$current_action${NC}"
        echo -e "Guardian Mode: ${YELLOW}Monitoring changes${NC}"
      fi
      ;;
    
    "blueprint")
      local action="$1"
      shift
      case "$action" in
        "add")
          # Add a critical path blueprint
          local name="$1"
          local entry="$2"
          echo -e "${BLUE}Adding critical path: $name${NC}"
          mkdir -p "$GUARDIAN_DIR"
          # Store blueprint (simplified for bash)
          echo "$name|$entry|$(date +%s)" >> "$GUARDIAN_DIR/blueprints.txt"
          echo -e "${GREEN}✓ Blueprint added. Define flow with 'blueprint flow $name file1 file2...'${NC}"
          ;;
        "analyze")
          # Analyze proposed change
          local file="$1"
          echo -e "${BLUE}🔍 Analyzing proposed change to: $file${NC}"
          
          # Check if file is in any critical path
          local in_critical_path=false
          local affected_paths=""
          
          if [ -f "$GUARDIAN_DIR/blueprints.txt" ]; then
            while IFS='|' read -r path_name entry_point timestamp; do
              # Simple check - in real implementation would parse flow
              if [[ "$file" == *"$entry_point"* ]]; then
                in_critical_path=true
                affected_paths="$affected_paths $path_name"
              fi
            done < "$GUARDIAN_DIR/blueprints.txt"
          fi
          
          if [ "$in_critical_path" = true ]; then
            echo -e "${YELLOW}⚠️  File is part of critical paths:$affected_paths${NC}"
            
            # Check with dependency system
            echo -e "\n${BLUE}Checking dependencies...${NC}"
            local deps=$(grep -l "$file" documentation/dependencies/dependency_index.md 2>/dev/null)
            if [ -n "$deps" ]; then
              echo -e "${YELLOW}This file is referenced in dependency index${NC}"
            fi
            
            # Check current action context
            if [ "$current_action" != "None" ] && [ -f ".aicheck/actions/${current_action,,}/$(echo $current_action | tr '[:upper:]' '[:lower:]')-plan.md" ]; then
              echo -e "\n${BLUE}Checking action plan...${NC}"
              local in_plan=$(grep -c "$file" ".aicheck/actions/${current_action,,}/$(echo $current_action | tr '[:upper:]' '[:lower:]')-plan.md" 2>/dev/null || echo "0")
              if [ "$in_plan" -gt 0 ]; then
                echo -e "${GREEN}✓ File modification is part of current action plan${NC}"
              else
                echo -e "${RED}❌ File not mentioned in current action plan${NC}"
                echo -e "${YELLOW}Consider updating action plan before proceeding${NC}"
              fi
            fi
            
            echo -e "\n${PURPLE}Change Impact Analysis:${NC}"
            echo -e "1. Run tests for affected paths"
            echo -e "2. Update documentation if contracts change"
            echo -e "3. Notify dependent modules"
            echo -e "4. Consider backward compatibility"
          else
            echo -e "${GREEN}✓ File is not in critical paths${NC}"
          fi
          ;;
        *)
          echo "Usage: ./aicheck guardian blueprint {add|analyze}"
          ;;
      esac
      ;;
    "analyze")
      # Deep analysis of proposed changes
      local file="$1"
      if [ -z "$file" ]; then
        echo -e "${RED}Please specify a file to analyze${NC}"
        return 1
      fi
      
      echo -e "${BLUE}🔬 Deep Analysis of: $file${NC}"
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      
      # Run conflict analyzer
      if [ -f ".aicheck/guardian/conflict_analyzer.sh" ]; then
        .aicheck/guardian/conflict_analyzer.sh "$file"
      fi
      
      # Check protection level
      local protection_level=$(grep "^$file|" "$PROTECTED_FILES" 2>/dev/null | cut -d'|' -f2)
      if [ -n "$protection_level" ]; then
        echo ""
        echo -e "${YELLOW}Protection Level: $protection_level${NC}"
        if [ "$protection_level" = "CRITICAL" ]; then
          echo -e "${RED}⚠️  This is a CRITICAL file - changes require approval${NC}"
        fi
      fi
      
      # Integration with AICheck validation
      echo ""
      echo -e "${BLUE}=== AICheck Validation ===${NC}"
      
      # Check if this fits current action
      local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
      if [ "$current_action" != "None" ]; then
        # Use AICheck's boundary checking
        local boundary_check=$(enforce_action_boundaries 2>&1 | grep -c "outside.*action" || echo "0")
        if [ "$boundary_check" -gt 0 ]; then
          echo -e "${RED}❌ Change may be outside current action boundaries${NC}"
        else
          echo -e "${GREEN}✓ Change appears within action boundaries${NC}"
        fi
      fi
      
      # Suggest next steps
      echo ""
      echo -e "${PURPLE}Recommended Actions:${NC}"
      echo "1. Review the analysis above"
      echo "2. Run tests: ./aicheck guardian test $file"
      echo "3. Update docs if needed: ./aicheck guardian doc $file"
      echo "4. If approved, update hash: ./aicheck guardian update $file"
      ;;
      
    *)
      echo -e "${BLUE}AICheck Guardian - Code Protection System${NC}"
      echo "Usage: ./aicheck guardian {init|protect|check|scan|status|blueprint|analyze}"
      echo ""
      echo "Commands:"
      echo "  init              Initialize guardian system"
      echo "  protect FILE LVL  Add file to protection (LVL: CRITICAL/SENSITIVE/MONITORED)"
      echo "  check/scan        Check file integrity"
      echo "  status            Show guardian status"
      echo "  blueprint         Manage critical path blueprints"
      echo "  analyze FILE      Deep analysis of proposed changes"
      ;;
  esac
}

# Function to define goals for auto-iterate session
function define_auto_iterate_goals() {
  local goals_file=".aicheck/auto-iterate-goals.md"
  
  echo -e "${BRIGHT_BLURPLE}🎯 Auto-Iterate Goal Definition${NC}"
  echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo -e ""
  echo -e "${YELLOW}The AI editor must propose specific, measurable goals for this iteration session.${NC}"
  echo -e "${YELLOW}Goals will be subject to human approval before proceeding.${NC}"
  echo -e ""
  
  # Analyze current test failures to inform goal proposal
  echo -e "${BLUE}🔍 Analyzing current test state...${NC}"
  local test_output=""
  local test_result=1
  
  if [ -f "pyproject.toml" ] && command -v poetry >/dev/null 2>&1; then
    echo -e "${BLUE}Running Poetry tests...${NC}"
    test_output=$(poetry run pytest -v 2>&1)
    test_result=$?
  elif [ -f "package.json" ]; then
    echo -e "${BLUE}Running npm tests...${NC}"
    test_output=$(npm test 2>&1)
    test_result=$?
    echo -e "${BLUE}Test completed with exit code: $test_result${NC}"
  else
    echo -e "${RED}No test configuration found. Cannot proceed without tests.${NC}"
    return 1
  fi
  
  if [ $test_result -eq 0 ]; then
    echo -e "${GREEN}✅ All tests currently pass. No iteration needed.${NC}"
    return 0
  fi
  
  # Extract failure information for goal formation
  local failed_tests=$(echo "$test_output" | grep "FAILED" | wc -l | tr -d ' ')
  local error_types=$(echo "$test_output" | grep -E "(ERROR|FAILED)" | head -5)
  local key_errors=$(echo "$test_output" | grep -E "(ImportError|ModuleNotFoundError|SyntaxError|AssertionError)" | head -3)
  
  echo -e "${RED}Current Test State:${NC}"
  echo -e "  Failed tests: ${RED}$failed_tests${NC}"
  echo -e "  Key issues:"
  echo "$error_types" | while read line; do
    [ -n "$line" ] && echo -e "    ${RED}• $line${NC}"
  done
  echo ""
  
  # AI Editor Goal Proposal Template
  echo -e "${PURPLE}🤖 AI EDITOR: Please propose specific goals for this auto-iterate session${NC}"
  echo -e "${PURPLE}Required format:${NC}"
  echo -e ""
  echo -e "GOAL 1: [Specific, measurable objective]"
  echo -e "  - Success criteria: [How to verify completion]"
  echo -e "  - Approach: [High-level strategy]"
  echo -e ""
  echo -e "GOAL 2: [Another specific objective]"
  echo -e "  - Success criteria: [How to verify completion]"
  echo -e "  - Approach: [High-level strategy]"
  echo -e ""
  echo -e "${YELLOW}Example goals:${NC}"
  echo -e "  • Fix all ImportError issues by updating dependencies"
  echo -e "  • Resolve syntax errors in test files"
  echo -e "  • Make failing assertion tests pass by correcting logic"
  echo -e "  • Achieve 100% test pass rate"
  echo -e ""
  
  # Get current active action to add template to action directory
  local current_action=$(cat .aicheck/current_action 2>/dev/null || echo "None")
  
  if [ "$current_action" != "None" ] && [ "$current_action" != "AICheckExec" ]; then
    # Add auto-iterate template to the active action's directory
    local dir_name=$(echo "$current_action" | sed 's/\([a-z0-9]\)\([A-Z]\)/\1-\2/g' | tr '[:upper:]' '[:lower:]')
    local action_dir=".aicheck/actions/$dir_name"
    local template_file="$action_dir/auto-iterate-session-plan.md"
    
    if [ -d "$action_dir" ]; then
      echo -e "${BLUE}Adding auto-iterate session template to active action: ${GREEN}$current_action${NC}"
      
      # Copy the auto-iterate action template to the action directory
      if [ -f "templates/claude/auto-iterate-action.md" ]; then
        cp "templates/claude/auto-iterate-action.md" "$template_file"
        
        # Customize template with current action details
        sed -i.backup \
          -e "s/\[ACTION-NAME\]/$current_action/g" \
          -e "s/\[DATE\]/$(date +"%Y-%m-%d")/g" \
          "$template_file"
        rm -f "$template_file.backup"
        
        echo -e "${GREEN}📝 Auto-iterate template added: ${BLUE}$template_file${NC}"
      else
        echo -e "${YELLOW}⚠️  Auto-iterate template not found. Creating basic template...${NC}"
        
        cat > "$template_file" << EOF
# Auto-Iterate Session for $current_action

**Action:** $current_action  
**Session Date:** $(date +"%Y-%m-%d %H:%M:%S")  
**Type:** Auto-Iterate Session

## Goals for This Session
<!-- AI editor will define specific goals during auto-iterate process -->

## Session Progress
<!-- Track multiple auto-iterate sessions within this action -->

## Integration with Action Plan
<!-- How this auto-iterate session supports the main action objectives -->

EOF
        echo -e "${GREEN}📝 Basic auto-iterate template created: ${BLUE}$template_file${NC}"
      fi
    else
      echo -e "${YELLOW}⚠️  Active action directory not found. Auto-iterate will work but no template added.${NC}"
    fi
  else
    echo -e "${YELLOW}⚠️  No active action. Auto-iterate will work independently.${NC}"
    echo -e "${BLUE}💡 Consider running './aicheck new ActionName' first to create an action context.${NC}"
  fi
  
  # Create template goals file for AI editor to fill
  cat > "$goals_file" << 'EOF'
# Auto-Iterate Session Goals
**Session Date:** $(date +"%Y-%m-%d %H:%M:%S")
**Current Action:** $(cat .aicheck/current_action 2>/dev/null || echo "None")

## Test Analysis
**Failed Tests:** $failed_tests
**Key Issues Identified:**
$error_types

## Proposed Goals
<!-- AI EDITOR: Fill in specific, measurable goals below -->

### GOAL 1: [Replace with specific objective]
- **Success Criteria:** [How to verify this goal is complete]
- **Approach:** [High-level strategy to achieve this goal]
- **Risk Assessment:** [What could go wrong]

### GOAL 2: [Replace with another specific objective]
- **Success Criteria:** [How to verify this goal is complete]
- **Approach:** [High-level strategy to achieve this goal]
- **Risk Assessment:** [What could go wrong]

## Constraints
- Maximum iterations: TBD
- Time limit: TBD
- No changes should be committed without human approval
- All changes must be reversible

## Success Definition
<!-- Overall session success is defined as: -->
[ ] All proposed goals completed
[ ] Test pass rate improved to X%
[ ] No regressions introduced
[ ] Code quality maintained

EOF
  
  # Substitute variables in the template (create new file to avoid sed issues)
  local temp_file=$(mktemp)
  sed \
    -e "s/\$failed_tests/$failed_tests/g" \
    -e "s|\$error_types|$error_types|g" \
    "$goals_file" > "$temp_file"
  mv "$temp_file" "$goals_file"
  
  echo -e "${GREEN}📝 Goals template created: ${BLUE}$goals_file${NC}"
  echo -e ""
  echo -e "${BRIGHT_BLURPLE}NEXT STEPS:${NC}"
  echo -e "1. ${YELLOW}AI Editor: Edit the goals file with specific, measurable objectives${NC}"
  echo -e "2. ${YELLOW}Human: Review and approve goals before proceeding${NC}"
  echo -e "3. ${YELLOW}Run: ./aicheck auto-iterate --execute to begin approved iteration${NC}"
  echo -e ""
  
  return 2  # Special return code indicating goals need to be defined
}

# Function to approve goals before iteration
function approve_auto_iterate_goals() {
  local goals_file=".aicheck/auto-iterate-goals.md"
  
  if [ ! -f "$goals_file" ]; then
    echo -e "${RED}No goals file found. Run './aicheck auto-iterate' first to define goals.${NC}"
    return 1
  fi
  
  echo -e "${BRIGHT_BLURPLE}🎯 Goal Approval Required${NC}"
  echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo -e ""
  echo -e "${BLUE}Current goals:${NC}"
  cat "$goals_file"
  echo -e ""
  echo -e "${YELLOW}Do you approve these goals for auto-iteration? ${NC}"
  echo -e "${GREEN}Options:${NC}"
  echo -e "  ${GREEN}y/yes${NC} - Approve and proceed with iteration"
  echo -e "  ${GREEN}e/edit${NC} - Edit goals file"
  echo -e "  ${GREEN}n/no${NC} - Cancel auto-iterate session"
  echo -e ""
  
  read -p "Your choice: " approval
  
  case "$approval" in
    "y"|"yes"|"Y"|"YES")
      echo -e "${GREEN}✅ Goals approved. Proceeding with auto-iteration...${NC}"
      return 0
      ;;
    "e"|"edit"|"E"|"EDIT")
      echo -e "${BLUE}Opening goals file for editing...${NC}"
      ${EDITOR:-nano} "$goals_file"
      echo -e "${YELLOW}Please run approval again after editing.${NC}"
      return 1
      ;;
    *)
      echo -e "${YELLOW}Auto-iterate session cancelled.${NC}"
      return 1
      ;;
  esac
}

# Function to run automated test-iterate-test cycles
function auto_iterate() {
  # Configuration defaults (can be overridden by config file)
  local default_max_iterations=10
  local default_timeout=300
  local default_auto_continue=true
  local default_human_timeout=30
  local default_test_timeout=120
  local default_enable_recovery=true
  
  # Check for config file
  if [ -f ".aicheck/auto-iterate.conf" ]; then
    source .aicheck/auto-iterate.conf
  fi
  
  # Parse arguments for goal definition vs execution
  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo -e "${BRIGHT_BLURPLE}Auto-Iterate Mode - Goal-Driven Test-Fix-Test Cycles${NC}"
    echo -e ""
    echo -e "${GREEN}Usage:${NC}"
    echo -e "  ./aicheck auto-iterate                    # Define goals (first step)"
    echo -e "  ./aicheck auto-iterate --approve          # Approve defined goals"
    echo -e "  ./aicheck auto-iterate --execute [args]   # Execute approved iteration"
    echo -e ""
    echo -e "${GREEN}Execution Options:${NC}"
    echo -e "  --execute [max_iterations] [timeout]     # Run with approved goals"
    echo -e ""
    echo -e "${GREEN}Examples:${NC}"
    echo -e "  ./aicheck auto-iterate                    # Step 1: Define goals"
    echo -e "  ./aicheck auto-iterate --approve          # Step 2: Human approval"
    echo -e "  ./aicheck auto-iterate --execute          # Step 3: Execute (defaults: $default_max_iterations iterations, ${default_timeout}s)"
    echo -e "  ./aicheck auto-iterate --execute 5        # Execute with max 5 iterations"
    echo -e ""
    echo -e "${YELLOW}Workflow:${NC}"
    echo -e "  1. AI editor analyzes failures and proposes goals"
    echo -e "  2. Human reviews and approves goals"
    echo -e "  3. System iterates toward approved goals"
    echo -e "  4. Human approves any changes before git commit"
    echo -e ""
    echo -e "${GREEN}Config file:${NC} .aicheck/auto-iterate.conf"
    echo -e "  default_max_iterations=$default_max_iterations"
    echo -e "  default_timeout=$default_timeout"
    return 0
  fi
  
  # Handle different phases
  if [[ "$1" == "--approve" ]]; then
    approve_auto_iterate_goals
    return $?
  elif [[ "$1" == "--execute" ]]; then
    shift  # Remove --execute from args
    execute_auto_iterate "$@"
    return $?
  elif [[ "$1" == "--summary" ]]; then
    # Find most recent session and generate summary
    local recent_session=$(ls .aicheck/auto-iterate-session-*.log 2>/dev/null | sort | tail -1)
    if [ -n "$recent_session" ]; then
      local session_id=$(basename "$recent_session" | sed 's/auto-iterate-session-\(.*\)\.log/\1/')
      echo -e "${BLUE}Generating summary for session: $session_id${NC}"
      generate_iteration_summary_and_git_approval "$session_id" "manual" "manual" ".aicheck/auto-iterate-changes-$session_id.md" "$recent_session"
    else
      echo -e "${RED}No auto-iterate sessions found${NC}"
      return 1
    fi
    return $?
  elif [[ "$1" == "--recover" ]]; then
    local session_id="$2"
    echo -e "${BLUE}Recovering auto-iterate session: $session_id${NC}"
    echo -e "${YELLOW}Recovery functionality will resume session state${NC}"
    echo -e "${RED}Recovery implementation needed in future version${NC}"
    return 1
  elif [[ "$1" == "--clean-recovery" ]]; then
    echo -e "${YELLOW}Cleaning up recovery files...${NC}"
    rm -f .aicheck/auto-iterate-state-*.tmp
    echo -e "${GREEN}✅ Recovery files cleaned${NC}"
    return 0
  else
    # Check for interrupted sessions before starting new one
    if check_auto_iterate_recovery; then
      local proceed=$(get_human_input "Proceed with new session anyway? (y/n):" 30 "n")
      if [[ ! "$proceed" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Use recovery options above or --clean-recovery to clear${NC}"
        return 1
      fi
    fi
    
    # Default: Goal definition phase
    define_auto_iterate_goals
    return $?
  fi
}

# Function to set up signal handlers for auto-iterate recovery
function setup_auto_iterate_signal_handlers() {
  local session_id="$1"
  local log_file="$2"
  local state_file="$3"
  
  # Create state file for recovery
  cat > "$state_file" << EOF
SESSION_ID=$session_id
LOG_FILE=$log_file
INTERRUPTED_AT=$(date +%s)
RECOVERY_AVAILABLE=true
EOF
  
  # Set up signal handlers
  trap "auto_iterate_graceful_shutdown $session_id $log_file $state_file" SIGINT SIGTERM SIGHUP
}

# Function to handle graceful shutdown of auto-iterate
function auto_iterate_graceful_shutdown() {
  local session_id="$1"
  local log_file="$2"
  local state_file="$3"
  
  echo "" >&2
  echo -e "${YELLOW}⚠️  Auto-iterate session interrupted${NC}" >&2
  echo "INTERRUPTED: Session $session_id stopped at $(date)" >> "$log_file"
  
  # Update state file
  echo "INTERRUPTED_AT=$(date +%s)" >> "$state_file"
  echo "RECOVERY_NEEDED=true" >> "$state_file"
  
  echo -e "${BLUE}Recovery information saved to: $state_file${NC}" >&2
  echo -e "${YELLOW}To resume: ./aicheck auto-iterate --recover $session_id${NC}" >&2
  echo -e "${YELLOW}To summarize: ./aicheck auto-iterate --summary${NC}" >&2
  
  exit 130  # Standard exit code for SIGINT
}

# Function to check for and handle recovery scenarios
function check_auto_iterate_recovery() {
  local recovery_files=$(ls .aicheck/auto-iterate-state-*.tmp 2>/dev/null | wc -l | tr -d ' ')
  
  if [ "$recovery_files" -gt 0 ]; then
    echo -e "${YELLOW}⚠️  Found $recovery_files interrupted auto-iterate session(s)${NC}"
    echo -e "${BLUE}Available recovery options:${NC}"
    
    for state_file in .aicheck/auto-iterate-state-*.tmp; do
      if [ -f "$state_file" ]; then
        source "$state_file"
        echo -e "  ${GREEN}./aicheck auto-iterate --recover $SESSION_ID${NC} - Resume session"
      fi
    done
    
    echo -e "  ${GREEN}./aicheck auto-iterate --clean-recovery${NC} - Clear all recovery files"
    echo ""
    return 0
  fi
  return 1
}

# Function to handle timeout-aware test execution
function run_tests_with_timeout() {
  local test_timeout=${1:-$default_test_timeout}
  local test_output=""
  local test_result=1
  
  echo -e "${BLUE}Running tests with ${test_timeout}s timeout...${NC}"
  
  if [ -f "pyproject.toml" ] && command -v poetry >/dev/null 2>&1; then
    # Use timeout command for Poetry tests
    if command -v timeout >/dev/null 2>&1; then
      test_output=$(timeout ${test_timeout}s poetry run pytest -v 2>&1)
      test_result=$?
      if [ $test_result -eq 124 ]; then
        test_output="$test_output\nTIMEOUT: Tests exceeded ${test_timeout}s limit"
        echo -e "${RED}⏰ Tests timed out after ${test_timeout}s${NC}"
      fi
    else
      test_output=$(poetry run pytest -v 2>&1)
      test_result=$?
    fi
  elif [ -f "package.json" ]; then
    # Use timeout command for npm tests
    if command -v timeout >/dev/null 2>&1; then
      test_output=$(timeout ${test_timeout}s npm test 2>&1)
      test_result=$?
      if [ $test_result -eq 124 ]; then
        test_output="$test_output\nTIMEOUT: Tests exceeded ${test_timeout}s limit"
        echo -e "${RED}⏰ Tests timed out after ${test_timeout}s${NC}"
      fi
    else
      test_output=$(npm test 2>&1)
      test_result=$?
    fi
  else
    test_output="No test configuration found"
    test_result=1
  fi
  
  # Return results via global variables (bash limitation workaround)
  echo "$test_result|$test_output"
}

# Function to handle human input with appropriate timeouts
function get_human_input() {
  local prompt="$1"
  local timeout_seconds=${2:-$default_human_timeout}
  local default_value="$3"
  
  echo -e "${YELLOW}$prompt${NC}"
  
  if [ -n "$default_value" ]; then
    echo -e "${BLUE}(Default: $default_value, timeout: ${timeout_seconds}s)${NC}"
  else
    echo -e "${BLUE}(Timeout: ${timeout_seconds}s)${NC}"
  fi
  
  local user_input=""
  if read -t "$timeout_seconds" -p "> " user_input; then
    if [ -z "$user_input" ] && [ -n "$default_value" ]; then
      echo "$default_value"
    else
      echo "$user_input"
    fi
  else
    echo -e "\n${YELLOW}⏰ Input timeout after ${timeout_seconds}s${NC}" >&2
    if [ -n "$default_value" ]; then
      echo -e "${BLUE}Using default: $default_value${NC}" >&2
      echo "$default_value"
    else
      echo "TIMEOUT"
    fi
  fi
}

# Function to execute the iteration with approved goals
function execute_auto_iterate() {
  local goals_file=".aicheck/auto-iterate-goals.md"
  
  # Check for approved goals
  if [ ! -f "$goals_file" ]; then
    echo -e "${RED}No goals file found. Run './aicheck auto-iterate' first to define goals.${NC}"
    return 1
  fi
  
  local max_iterations=${1:-$default_max_iterations}
  local timeout=${2:-$default_timeout}
  
  # Validate inputs
  if ! [[ "$max_iterations" =~ ^[0-9]+$ ]] || [ "$max_iterations" -eq 0 ]; then
    echo -e "${RED}Error: max_iterations must be a positive integer${NC}"
    return 1
  fi
  
  if ! [[ "$timeout" =~ ^[0-9]+$ ]] || [ "$timeout" -eq 0 ]; then
    echo -e "${RED}Error: timeout must be a positive integer (seconds)${NC}"
    return 1
  fi
  
  # Initialize iteration tracking
  local iteration=1
  local start_time=$(date +%s)
  local session_id=$(date +%Y%m%d_%H%M%S)
  local log_file=".aicheck/auto-iterate-session-$session_id.log"
  local changes_file=".aicheck/auto-iterate-changes-$session_id.md"
  local state_file=".aicheck/auto-iterate-state-$session_id.tmp"
  local git_initial_state=$(git rev-parse HEAD 2>/dev/null || echo "NO_GIT")
  
  # Set up signal handlers for graceful shutdown
  if [ "$default_enable_recovery" = true ]; then
    setup_auto_iterate_signal_handlers "$session_id" "$log_file" "$state_file"
  fi
  
  # Create detailed session log
  mkdir -p .aicheck
  echo "# Auto-Iterate Session Log" > "$log_file"
  echo "Session ID: $session_id" >> "$log_file"
  echo "Start Time: $(date)" >> "$log_file"
  echo "Goals File: $goals_file" >> "$log_file"
  echo "Initial Git State: $git_initial_state" >> "$log_file"
  echo "Max Iterations: $max_iterations" >> "$log_file"
  echo "Timeout: $timeout seconds" >> "$log_file"
  echo "" >> "$log_file"
  
  # Initialize changes tracking
  echo "# Auto-Iterate Changes Summary" > "$changes_file"
  echo "**Session:** $session_id" >> "$changes_file"
  echo "**Start Time:** $(date)" >> "$changes_file"
  echo "" >> "$changes_file"
  echo "## Goals" >> "$changes_file"
  echo '```' >> "$changes_file"
  cat "$goals_file" >> "$changes_file"
  echo '```' >> "$changes_file"
  echo "" >> "$changes_file"
  echo "## Changes Made" >> "$changes_file"
  
  echo -e "${BRIGHT_BLURPLE}🚀 Starting Goal-Driven Auto-Iterate Execution${NC}"
  echo -e "Session ID: ${BLUE}$session_id${NC}"
  echo -e "Max iterations: ${GREEN}$max_iterations${NC}"
  echo -e "Timeout: ${GREEN}$timeout${NC}s"
  echo -e "Goals: ${BLUE}$goals_file${NC}"
  echo -e ""
  
  # Main iteration loop
  while [ $iteration -le $max_iterations ]; do
    local current_time=$(date +%s)
    local elapsed=$((current_time - start_time))
    
    # Check timeout
    if [ $elapsed -gt $timeout ]; then
      echo -e "${YELLOW}⏰ Timeout reached after ${elapsed}s${NC}"
      echo "TIMEOUT: Session exceeded $timeout seconds" >> "$log_file"
      break
    fi
    
    echo -e "${BRIGHT_BLURPLE}Iteration $iteration/$max_iterations${NC} (${elapsed}s elapsed)"
    echo "=== Iteration $iteration - $(date) ===" >> "$log_file"
    
    # Step 1: Run tests with timeout and check against goals
    echo -e "${YELLOW}🧪 Running tests...${NC}"
    
    # Use timeout-aware test execution
    local test_results=$(run_tests_with_timeout $default_test_timeout)
    local test_result=$(echo "$test_results" | cut -d'|' -f1)
    local test_output=$(echo "$test_results" | cut -d'|' -f2-)
    
    # Handle test timeout specifically
    if [ $test_result -eq 124 ]; then
      echo -e "${RED}❌ Tests timed out after ${default_test_timeout}s${NC}"
      echo "TIMEOUT: Tests exceeded timeout limit" >> "$log_file"
      
      local timeout_action=$(get_human_input "Tests timed out. Options: (r)etry, (i)ncrease timeout, (s)kip, (q)uit:" 60 "retry")
      
      case "$timeout_action" in
        "r"|"retry")
          echo -e "${BLUE}Retrying tests...${NC}"
          continue
          ;;
        "i"|"increase")
          default_test_timeout=$((default_test_timeout * 2))
          echo -e "${BLUE}Increased test timeout to ${default_test_timeout}s${NC}"
          continue
          ;;
        "s"|"skip")
          echo -e "${YELLOW}Skipping this iteration due to test timeout${NC}"
          iteration=$((iteration + 1))
          continue
          ;;
        *)
          echo -e "${YELLOW}Quitting due to test timeout${NC}"
          break
          ;;
      esac
    fi
    
    # Log test results
    echo "Test Exit Code: $test_result" >> "$log_file"
    echo "Test Output:" >> "$log_file"
    echo "$test_output" >> "$log_file"
    echo "" >> "$log_file"
    
    # Check if goals are met
    if [ $test_result -eq 0 ]; then
      echo -e "${GREEN}✅ All tests pass! Checking if goals are fulfilled...${NC}"
      
      # Here we'd need AI editor to verify goals are met
      echo -e "${PURPLE}🤖 AI EDITOR: Verify that approved goals have been achieved${NC}"
      echo -e "${YELLOW}Review the goals in: ${BLUE}$goals_file${NC}"
      local goals_satisfied=$(get_human_input "Are all goals satisfied? (y/n):" $default_human_timeout)
      
      if [[ "$goals_satisfied" =~ ^[Yy] ]]; then
        echo -e "${GREEN}🎉 Goals achieved! Auto-iterate complete.${NC}"
        echo "SUCCESS: All goals achieved after $iteration iteration(s)" >> "$log_file"
        break
      else
        echo -e "${YELLOW}Goals not fully met. Continuing iteration...${NC}"
      fi
    fi
    
    # Step 2: Analyze failures and track changes
    echo -e "${RED}❌ Tests still failing${NC}"
    echo -e "${YELLOW}🔍 Analyzing failures against goals...${NC}"
    
    local failed_tests=$(echo "$test_output" | grep "FAILED" | wc -l | tr -d ' ')
    local error_summary=$(echo "$test_output" | grep -E "(FAILED|ERROR|AssertionError|SyntaxError|ImportError)" | head -3)
    
    echo -e "${YELLOW}Failed tests: ${RED}$failed_tests${NC}"
    if [ -n "$error_summary" ]; then
      echo -e "${YELLOW}Key errors:${NC}"
      echo "$error_summary" | while read line; do
        echo -e "  ${RED}• $line${NC}"
      done
    fi
    
    # Track git changes if any
    local git_changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$git_changes" -gt 0 ]; then
      echo "### Iteration $iteration Changes" >> "$changes_file"
      echo "**Time:** $(date)" >> "$changes_file"
      echo "**Test Result:** $test_result (exit code)" >> "$changes_file"
      echo "**Files Modified:**" >> "$changes_file"
      git status --porcelain >> "$changes_file"
      echo "" >> "$changes_file"
    fi
    
    # Step 3: Allow human intervention or automated fixes
    echo -e "${PURPLE}Options for iteration $iteration:${NC}"
    echo -e "  ${GREEN}c${NC} - Continue to next iteration"
    echo -e "  ${GREEN}i${NC} - Intervene manually (pause iteration)"
    echo -e "  ${GREEN}q${NC} - Quit iteration session"
    echo -e "  ${GREEN}s${NC} - Summary and finish"
    
    local action=$(get_human_input "Action:" 15 "c")
    
    case "$action" in
      "i"|"intervene")
        echo -e "${BLUE}Pausing for manual intervention...${NC}"
        echo "MANUAL_INTERVENTION: User requested pause at iteration $iteration" >> "$log_file"
        echo -e "${YELLOW}Make your changes, then run:${NC}"
        echo -e "  ${GREEN}./aicheck auto-iterate --execute $max_iterations $timeout${NC} (to resume)"
        echo -e "  ${GREEN}./aicheck auto-iterate --summary${NC} (to finish and review)"
        return 2
        ;;
      "q"|"quit")
        echo -e "${YELLOW}Auto-iterate stopped by user${NC}"
        echo "STOPPED: User quit at iteration $iteration" >> "$log_file"
        break
        ;;
      "s"|"summary")
        echo -e "${YELLOW}Proceeding to summary${NC}"
        break
        ;;
      *)
        echo -e "${BLUE}Continuing to next iteration...${NC}"
        ;;
    esac
    
    iteration=$((iteration + 1))
    echo ""
  done
  
  # Generate final summary and request git approval
  generate_iteration_summary_and_git_approval "$session_id" "$iteration" "$start_time" "$changes_file" "$log_file"
}

# Function to generate summary and handle git approval
function generate_iteration_summary_and_git_approval() {
  local session_id="$1"
  local final_iteration="$2"
  local start_time="$3"
  local changes_file="$4"
  local log_file="$5"
  
  local final_time=$(date +%s)
  local total_elapsed=$((final_time - start_time))
  local summary_file=".aicheck/auto-iterate-summary-$session_id.md"
  
  echo -e "${BRIGHT_BLURPLE}📋 Auto-Iterate Session Complete${NC}"
  echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  
  # Generate comprehensive summary
  cat > "$summary_file" << EOF
# Auto-Iterate Session Summary

**Session ID:** $session_id  
**Total Duration:** ${total_elapsed}s ($(($total_elapsed / 60))m $(($total_elapsed % 60))s)  
**Iterations Completed:** $((final_iteration - 1))  
**End Time:** $(date)

## Session Overview

### Goals Review
EOF
  
  cat .aicheck/auto-iterate-goals.md >> "$summary_file"
  
  cat >> "$summary_file" << EOF

### Changes Made
EOF
  
  if [ -f "$changes_file" ]; then
    cat "$changes_file" >> "$summary_file"
  else
    echo "No changes tracked during this session." >> "$summary_file"
  fi
  
  cat >> "$summary_file" << EOF

### Git Status
**Files Modified:**
\`\`\`
$(git status --porcelain 2>/dev/null || echo "No git repository")
\`\`\`

**Git Diff Summary:**
\`\`\`
$(git diff --stat 2>/dev/null || echo "No changes")
\`\`\`

### Final Test Results
\`\`\`
$(if [ -f "pyproject.toml" ] && command -v poetry >/dev/null 2>&1; then
    poetry run pytest --tb=short 2>&1 | tail -10
  elif [ -f "package.json" ]; then
    npm test 2>&1 | tail -10
  else
    echo "No test configuration"
  fi)
\`\`\`

## Recommendations

### Achieved
- [ ] List what was successfully completed
- [ ] Note any goals that were fully met
- [ ] Document any improvements made

### Still Needed
- [ ] List remaining issues
- [ ] Note any goals not achieved
- [ ] Suggest next steps

### Code Quality
- [ ] No regressions introduced
- [ ] Code follows project standards
- [ ] Tests are comprehensive
- [ ] Documentation updated if needed

EOF
  
  # Display summary
  echo -e "${BLUE}Summary generated: ${BRIGHT_BLURPLE}$summary_file${NC}"
  echo -e ""
  echo -e "${YELLOW}Session Statistics:${NC}"
  echo -e "  Total time: ${GREEN}${total_elapsed}s${NC} ($(($total_elapsed / 60))m $(($total_elapsed % 60))s)"
  echo -e "  Iterations: ${GREEN}$((final_iteration - 1))${NC}"
  echo -e "  Log file: ${BLUE}$log_file${NC}"
  echo -e ""
  
  # Check for git changes
  local git_changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
  if [ "$git_changes" -eq 0 ]; then
    echo -e "${GREEN}✅ No changes to commit${NC}"
    echo -e "${BLUE}Session complete - no git action needed${NC}"
    return 0
  fi
  
  # Git approval workflow
  echo -e "${BRIGHT_BLURPLE}🔄 Git Commit Approval Required${NC}"
  echo -e "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo -e ""
  echo -e "${YELLOW}Changes detected in working directory:${NC}"
  git status --short
  echo -e ""
  echo -e "${YELLOW}Do you want to commit these changes? ${NC}"
  echo -e "${GREEN}Options:${NC}"
  echo -e "  ${GREEN}y/yes${NC} - Commit changes with auto-generated message"
  echo -e "  ${GREEN}c/custom${NC} - Commit with custom message"
  echo -e "  ${GREEN}r/review${NC} - Review detailed diff first"
  echo -e "  ${GREEN}n/no${NC} - Don't commit (keep changes staged)"
  echo -e "  ${GREEN}d/discard${NC} - Discard all changes (DANGEROUS!)"
  echo -e ""
  
  local commit_choice=$(get_human_input "Your choice:" 60)
  
  case "$commit_choice" in
    "y"|"yes"|"Y"|"YES")
      # Auto-generated commit message
      local commit_msg="Auto-iterate session $session_id: $(git status --porcelain | wc -l | tr -d ' ') files modified

Auto-iterate session completed with $((final_iteration - 1)) iterations.
Total duration: ${total_elapsed}s

Changes made during automated test-fix cycles.
See summary: $summary_file

🤖 Generated with AICheck auto-iterate mode"
      
      git add -A
      git commit -m "$commit_msg"
      echo -e "${GREEN}✅ Changes committed successfully${NC}"
      ;;
      
    "c"|"custom"|"C"|"CUSTOM")
      echo -e "${BLUE}Enter custom commit message:${NC}"
      read -p "> " custom_msg
      if [ -n "$custom_msg" ]; then
        git add -A
        git commit -m "$custom_msg

Auto-iterate session: $session_id
Duration: ${total_elapsed}s, Iterations: $((final_iteration - 1))
See summary: $summary_file"
        echo -e "${GREEN}✅ Changes committed with custom message${NC}"
      else
        echo -e "${YELLOW}Empty message. Changes not committed.${NC}"
      fi
      ;;
      
    "r"|"review"|"R"|"REVIEW")
      echo -e "${BLUE}Reviewing changes...${NC}"
      git diff --cached
      echo -e ""
      echo -e "${YELLOW}Commit these changes? (y/n): ${NC}"
      read -p "> " review_commit
      if [[ "$review_commit" =~ ^[Yy] ]]; then
        git commit -m "Auto-iterate session $session_id

Reviewed and approved changes from automated iteration.
Duration: ${total_elapsed}s, Iterations: $((final_iteration - 1))
See summary: $summary_file"
        echo -e "${GREEN}✅ Changes committed after review${NC}"
      else
        echo -e "${YELLOW}Changes not committed${NC}"
      fi
      ;;
      
    "d"|"discard"|"D"|"DISCARD")
      echo -e "${RED}⚠️  This will discard ALL changes from the session!${NC}"
      echo -e "${YELLOW}Are you absolutely sure? (type 'discard' to confirm): ${NC}"
      read -p "> " confirm_discard
      if [ "$confirm_discard" = "discard" ]; then
        git reset --hard HEAD
        git clean -fd
        echo -e "${RED}All changes discarded${NC}"
      else
        echo -e "${YELLOW}Discard cancelled. Changes preserved.${NC}"
      fi
      ;;
      
    *)
      echo -e "${YELLOW}Changes not committed. Files remain modified.${NC}"
      echo -e "${BLUE}You can commit later using standard git commands${NC}"
      ;;
  esac
  
  echo -e ""
  echo -e "${GREEN}Auto-iterate session complete!${NC}"
  echo -e "${BLUE}Summary: ${BRIGHT_BLURPLE}$summary_file${NC}"
  echo -e "${BLUE}Log: ${BRIGHT_BLURPLE}$log_file${NC}"
}

# Auto-detect new sessions and run startup checks
# auto_session_start_check  # Temporarily disabled for testing

# Main command handling
case "$CMD" in
  "new")
    # Shortcut for action new
    create_action "$1"
    ;;
  "active"|"ACTIVE")
    # Shortcut for action set
    set_active_action "$1"
    ;;
  "complete"|"Complete"|"COMPLETE")
    # Shortcut for action complete
    complete_action "$1"
    ;;
  "status")
    # Show current status
    show_status
    ;;
  "stuck")
    # Get unstuck help
    show_status
    echo -e ""
    echo -e "${BRIGHT_BLURPLE}🆘 Getting Unstuck${NC}"
    echo -e ""
    echo -e "${YELLOW}If you're feeling lost, here's what to check:${NC}"
    echo -e "1. ${GREEN}./aicheck status${NC} - See current action status"
    echo -e "2. ${GREEN}./aicheck focus${NC} - Check for scope creep"
    echo -e "3. ${GREEN}./aicheck cleanup${NC} - Clean up and optimize"
    echo -e "4. ${GREEN}./aicheck deploy${NC} - Pre-deployment check"
    echo -e ""
    echo -e "${PURPLE}Need to start fresh?${NC}"
    echo -e "• ${GREEN}./aicheck new ActionName${NC} - Create new action"
    echo -e "• ${GREEN}./aicheck ACTIVE ActionName${NC} - Switch to action"
    ;;
  "focus")
    # Check for scope creep and compliance issues
    check_compliance
    ;;
  "cleanup")
    # Clean up and optimize
    cleanup_compliance
    ;;
  "deploy")
    # Shortcut for deploy-check
    $0 deploy-check
    ;;
  "usage")
    # Show AI usage and costs
    mcp__aicheck__aicheck_analyzeCosts 2>/dev/null || echo -e "${YELLOW}Usage tracking not available - MCP server not connected${NC}"
    ;;
  "auto-iterate"|"iterate"|"auto")
    # Auto-iterate mode: test, analyze, fix, repeat
    auto_iterate "$1" "$2"
    ;;
  "version"|"--version")
    # Show version information
    show_version
    ;;
  *)
    echo -e "${RED}❌ Unknown command: $CMD${NC}"
    echo -e ""
    echo -e "${BRIGHT_BLURPLE}Try these instead:${NC}"
    echo -e "  ${GREEN}./aicheck stuck${NC}     - Get help and see what's happening"
    echo -e "  ${GREEN}./aicheck focus${NC}     - Check if you're on track"
    echo -e "  ${GREEN}./aicheck cleanup${NC}   - Clean up files and optimize"
    echo -e "  ${GREEN}./aicheck version${NC}   - See all available commands"
    ;;
esac
